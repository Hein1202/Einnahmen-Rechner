<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Einnahmen V267.02.26</title>
<style>
body { margin:0; padding:0; }
.container { max-width:600px; margin:0 auto; background:white; padding:20px; }
h1 { margin-top:0; }

#selected-month {
  font-weight:bold;
  font-size:1.6em;
  color:#b30000;
  background:#ffe5e5;
  padding:5px 12px;
  border-radius:8px;
}

#month-nav { font-size:1.4em; margin:10px 0; display:flex; align-items:center; justify-content:space-between; }
.nav { cursor:pointer; font-weight:bold; padding:0 10px; }

table { width:100%; border-collapse:collapse; background:#f5f5dc; }
th, td { border:1px solid black; padding:6px; text-align:center; }

/* Grundlegendes Styling f√ºr Betragsfelder und Trinkgeld */
.amount1,
.amount2,
.amountTip {
  background-color: #f3f4f6;
  box-sizing: border-box;
  padding: 8px;
  border: 1px solid black;
  text-align: center;
  width: 60%;
  max-width: 120px;
  min-width: 60px;
  display: block;
  margin: 0 auto;
}
.toggle-tip {
  margin-left: 4px;
}

/* Zellen der Eingabezeilen oben ausrichten, damit Betrag 1 und Betrag 2
   (inkl. Button) b√ºndig nebeneinander stehen. */
tr.entry-row td {
  vertical-align: top;
}

/* Wrapper von Betrag 2 kompakt halten und neben Betrag 1 platzieren */
.amount2-wrapper {
  display: inline-block;
  vertical-align: top;
  margin: 0;
  padding: 0;
}
.amount1-wrapper {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.amount1-wrapper input.amount1 {
  font-size: 1.08em;
  min-width: 0;
  padding-right: 4px;
}

/* Standardbetrag-Button links neben dem Feld */
.std-amount-btn {
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 1px solid #999;
  background: #ffffff;
  font-size: 0.9em;
  font-weight: 700;
  cursor: pointer;
  display: inline-flex; /* Platz immer reservieren ‚Üí kein Springen */
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  align-items: center;
  justify-content: center;
  padding: 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  transition: background-color 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease, transform 0.08s ease, opacity 0.08s ease;
}

.std-amount-btn:focus-visible {
  outline: 2px solid #93c5fd;
  outline-offset: 2px;
}

.std-amount-btn.visible {
  visibility: visible;
  opacity: 1;
  pointer-events: auto;
}

.std-amount-btn:hover {
  background: #eef2ff;
  border-color: #6b8cff;
  box-shadow: 0 3px 7px rgba(0,0,0,0.16);
  transform: translateY(-1px);
}

.amount-error-hint {
  margin-top: 2px;
  font-size: 0.8em;
  color: #b30000;
}


/* Toggle-Button direkt unter dem zweiten Feld, ohne extra Abstand nach oben */
.toggle-amount2 {
  display: inline-block;
  vertical-align: top;
  margin-top: 0;
  font-size: 0.8em;
  padding: 2px 6px;
  cursor: pointer;
}

.empty-input { background-color:lightgray; }
.amount1:not(.empty-input) {
  font-weight: bold;
}

.weekend, .holiday, .customfree {
  background:#ddd;
  font-weight:bold;
  font-style:italic;
}

/* Spezielle Farben f√ºr Beschriftung von Urlaub und Krankheit */
.customfree .day-cell small .label-urlaub {
  color: #2a8f3a;
}
.customfree .day-cell small .label-krank {
  color: #3a5f85;
}
.day-cell { cursor:pointer; font-weight:bold; }

/* Sonntage und Feiertage: Tageszahl + Text in Rot darstellen */
.weekend.sunday .day-cell,
.weekend.sunday .day-cell small,
.holiday .day-cell,
.holiday .day-cell small {
  color: #b30000;
}

/* Druckmodus optimieren */

#main-table th:nth-child(2),
#main-table td:nth-child(2) {
  width: 120px;
}

#main-table th:nth-child(3),
#main-table td:nth-child(3) {
  width: 90px;
}

#main-table th:nth-child(4),
#main-table td:nth-child(4) {
  width: 80px;
}


input[type="text"] {
  border: 1px solid #d1d5db;
  border-radius: 6px;
  padding: 4px 6px;
  box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
  transition: border-color 0.12s ease, box-shadow 0.12s ease, background-color 0.12s ease;
}

input[type="text"]:focus {
  outline: none;
  border-color: #2563eb;
  box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
  background-color: #eff6ff;
}

@media print {
  button, input[type=file] {
    display:none !important;
  }
  body {
    color:black !important;
    background:white !important;
  }
  #selected-month {
    background:white !important;
    color:black !important;
  }
}





.nav-btn {
  font-size: 1.4em;
  padding: 6px 12px;
  margin: 0 10px;
  cursor: pointer;
  font-weight: bold;
  border: 2px solid #444;
  background: #eee;
  border-radius: 6px;
}


/* Scroll button to jump from a day to the monthly overview */
/* Base cell style: empty by default */
.scroll-to-summary {
  cursor: default;
  padding: 0 4px;
  font-size: 0.95em;
}

/* Ensure the numeric part of the daily sum in a scroll-to-summary cell
   has the same font weight and spacing as normal table cells. Without
   this rule, the sum may appear bolder or cramped when multiple
   amounts exist for a day because it is wrapped inside a span. */
.scroll-to-summary .sum-value {
  /* Make the sum bold and the same size as the input fields when values are entered */
  font-weight: bold !important;
  font-size: 1.08em;
  /* Match the font size of input fields (1.08em) so the sum does not appear
     smaller when multiple amounts exist. */
  margin-right: 4px;
}

/* Always display the Summe column values in bold and with the same font size
   as the input fields, regardless of whether the scroll arrow is present.
   This targets the <td> elements with id="sum-<day>". */
td[id^="sum-"] {
  font-weight: bold !important;
  font-size: 1.08em;
}

/* As an additional safeguard, apply the bold styling to the fifth column
   (Summe) in all entry rows. This ensures sums remain bold even when
   the scroll indicator isn't active or the sum cell structure changes. */
#main-table tr.entry-row > td:nth-child(5) {
  font-weight: bold;
  font-size: 1.08em;
}

/* Kreis mit Pfeil */
.scroll-circle {
  display: inline-flex;
  align-items: center;
  justify-content: center;

  cursor: pointer;  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 2px solid #244b79;
  background: #cfe2ff; /* leichtes Blau */
  font-size: 1.3em;
  line-height: 1;
  font-weight: bold;
}

/* Text neben dem Kreis */
.scroll-text {
  margin-left: 4px;
  white-space: nowrap;
}
.scroll-back-wrapper {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  margin-top: 4px;
}

/* Dezenteres Styling f√ºr den Zur√ºck-Pfeil und seine Beschriftung:
   kleinerer Kreis, d√ºnnerer Rand und hellere Farben. */
.scroll-back-wrapper .scroll-circle {
  width: 26px;
  height: 26px;
  border-width: 1px;
  border-radius: 50%;
  background: #eaf2fb;
  font-size: 1.1em;
  color: #244b79;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.scroll-back-wrapper .scroll-text {
  font-size: 0.9em;
  color: #244b79;
  margin-left: 4px;
}

/* F√ºr den Scroll-Pfeil in der Tagesspalte (zur Monats√ºbersicht) ein dezenteres Styling:
   kleinerer Kreis, d√ºnnerer Rand und hellere Farben sowie kleinere Schrift f√ºr die Beschriftung. */
/* Feinere Abmessungen f√ºr den Pfeil und Text innerhalb eines Tagessummenfeldes */
.scroll-to-summary .scroll-circle {
  width: 22px;
  height: 22px;
  border-width: 1px;
  border-radius: 50%;
  background: #eaf2fb;
  font-size: 1em;
  color: #244b79;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.scroll-to-summary .scroll-text {
  font-size: 0.85em;
  color: #244b79;
  margin-left: 3px;
}
.missing-day-hint-inline {
  margin-top: 6px;
  padding: 8px 10px;
  border: 2px solid #b30000;
  background: #ffecec;
  color: #b30000;
  font-weight: bold;
  border-radius: 6px;
  font-size: 0.9em;
}



/* Highlight auf dem Kreis bei Hover */
.scroll-to-summary:hover .scroll-circle {
  background: #d8eaff;
}

/* Entferne Auf-/Ab-Pfeile (Spinner) in number-Feldern, um den Inhalt komplett anzuzeigen */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.modern-btn {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.95em;
  font-weight: 600;
  background: linear-gradient(135deg, #2563eb, #1d4ed8);
  color: #ffffff;
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.35);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.18s ease;
}

.modern-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.35);
  filter: brightness(1.04);
}

.modern-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.3);
  filter: brightness(0.96);
}

.modern-btn:focus-visible {
  outline: 2px solid #93c5fd;
  outline-offset: 2px;
}
.excel-btn {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.95em;
  font-weight: 600;
  background: linear-gradient(135deg, #22c55e, #16a34a);
  color: #ffffff;
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.35);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.18s ease;
}

.excel-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.35);
  filter: brightness(1.05);
}

.excel-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.3);
  filter: brightness(0.95);
}

.excel-btn:focus-visible {
  outline: 2px solid #bbf7d0;
  outline-offset: 2px;
}

input[type="number"] {
  -moz-appearance: textfield; /* f√ºr Firefox */
}


.bg-blue   { background-color: #e0f0ff; }
.bg-green  { background-color: #e8ffe8; }
.bg-yellow { background-color: #fffbe0; }
.bg-dark   { background-color: #1e1e1e; color: white; }

.bg-darkblue { background-color: #b0c4de; } /* steelblue/light slate blue */

/* √Ñu√üerer Rahmen pro Tag */
tbody[id^="day-"] {
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 10px;
  border-collapse: separate;
  border-spacing: 0;
}

/* Keine Rahmen innerhalb eines Tagesblocks */
tbody[id^="day-"] td,
tbody[id^="day-"] tr {
  border: none !important;
  outline: none !important;
}

/* Inputs bleiben sichtbar, aber dezent */
tbody[id^="day-"] input {
  border: 1px solid #9ca3af;
  border-radius: 6px;
  padding: 4px 6px;
  box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.12);
  background-color: #ffffff;

}


/* Gr√∂√üere Darstellung der Tageszahlen (erste Spalte) */
tbody[id^="day-"] tr:first-child td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Auch Tageszahlen in freien Tagen (z.‚ÄØB. Samstag, Sonntag, Feiertag) gr√∂√üer darstellen */
tr.frei td span.fett {
  font-size: 1.4em;
}


/* Auch regul√§re Tageszahlen gr√∂√üer darstellen */
tbody[id^="day-"] tr td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Tagessumme (rechts unten) und Kundenanzahl fett */
tbody[id^="day-"] tr:last-child td:last-child,
tbody[id^="day-"] tr:last-child td:nth-last-child(2) {
  font-weight: bold;
}


.tg-cell {
  min-width: 60px;
}

.amount1 {
  font-size: 1.08em;
  box-shadow: 0 0 10px rgba(37, 99, 235, 0.65);
  border-radius: 6px;
}
</style>
<script>
// --- Globale Variablen ---
const monthNames = ["Januar","Februar","M√§rz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"];
let now = new Date();
let selMonth = now.getMonth();
let selYear = now.getFullYear();
let selDays = 0;
let holidays = {};

// Erkennung, ob das Ger√§t ein Touch-Ger√§t (Smartphone/Tablet) ist.
const isTouchDevice = ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

// --- Hilfsfunktionen Datum ---
function daysInMonth(y, m){ return new Date(y, m+1, 0).getDate(); }

function fmt(d){
  return d.getFullYear() + "-" +
         String(d.getMonth()+1).padStart(2,"0") + "-" +
         String(d.getDate()).padStart(2,"0");
}
function addDays(d, x){
  let n = new Date(d);
  n.setDate(n.getDate() + x);
  return n;
}

// Ostersonntag nach Gau√ü
function calcEaster(Y){
  let a = Y % 19;
  let b = Math.floor(Y / 100);
  let c = Y % 100;
  let d = Math.floor(b / 4);
  let e = b % 4;
  let f = Math.floor((b + 8) / 25);
  let g = Math.floor((b - f + 1) / 3);
  let h = (19*a + b - d - g + 15) % 30;
  let i = Math.floor(c / 4);
  let k = c % 4;
  let l = (32 + 2*e + 2*i - h - k) % 7;
  let m = Math.floor((a + 11*h + 22*l) / 451);
  let month = Math.floor((h + l - 7*m + 114) / 31);
  let day = ((h + l - 7*m + 114) % 31) + 1;
  return new Date(Y, month - 1, day);
}

function getNRWHolidays(year){
  let easter = calcEaster(year);
  let H = {};
  H[fmt(new Date(year,0,1))]  = "Neujahr";
  H[fmt(new Date(year,4,1))]  = "Tag der Arbeit";
  H[fmt(new Date(year,9,3))]  = "Tag der Deutschen Einheit";
  H[fmt(new Date(year,11,25))] = "1. Weihnachtstag";
  H[fmt(new Date(year,11,26))] = "2. Weihnachtstag";
  H[fmt(new Date(year,10,1))] = "Allerheiligen";
  H[fmt(addDays(easter,-2))]  = "Karfreitag";
  H[fmt(addDays(easter, 1))]  = "Ostermontag";
  H[fmt(addDays(easter,39))]  = "Christi Himmelfahrt";
  H[fmt(addDays(easter,50))]  = "Pfingstmontag";
  H[fmt(addDays(easter,60))]  = "Fronleichnam";
  return H;
}

// --- Design-Helfer ---
function checkInput(input){
  if(!input) return;
  if(input.value === "") input.classList.add("empty-input");
  else input.classList.remove("empty-input");

  const row = input.closest("tr.entry-row");

  // Wenn Betrag 1 ge√§ndert wird und jetzt einen Wert hat,
  // einen evtl. vorhandenen Hinweis bei Betrag 2 in derselben Zeile ausblenden.
  if (row && input.classList.contains("amount1") && input.value !== "") {
    const wrapper2 = row.querySelector(".amount2-wrapper");
    if (wrapper2) {
      const hint = wrapper2.querySelector(".amount-error-hint");
      if (hint) hint.remove();
    }
  }

  // Zus√§tzliche Plausibilit√§tspr√ºfung: Wenn in Betrag 2 ein Wert
  // eingegeben wird, aber Betrag 1 in derselben Zeile leer ist,
  // einen optischen Hinweis unter dem Feld anzeigen und die Eingabe
  // in Betrag 2 zur√ºcknehmen.
  if (row && input.classList.contains("amount2") && input.value !== "") {
    const a1 = row.querySelector(".amount1");
    if (a1 && !a1.value) {
      const wrapper2 = row.querySelector(".amount2-wrapper");
      if (wrapper2) {
        let hint = wrapper2.querySelector(".amount-error-hint");
        if (!hint) {
          hint = document.createElement("div");
          hint.className = "amount-error-hint";
          wrapper2.appendChild(hint);
        }
        hint.textContent = "Bitte zuerst Betrag 1 eingeben.";
      }
      input.value = "";
      input.classList.add("empty-input");
      const day = typeof getDayFromEntryRow === "function"
        ? getDayFromEntryRow(row)
        : null;
      if (day != null) {
        updateDay(day);
      }
      a1.focus();
    }
  }
}

function toggleAmount2(btn, day){
  const wrapper = btn.parentElement.querySelector(".amount2-wrapper");
  const input = wrapper.querySelector(".amount2");
  if(wrapper.style.display === "none" || wrapper.style.display === ""){
    wrapper.style.display = "block";
    btn.textContent = "‚àí Betrag 2";
  } else {
    wrapper.style.display = "none";
    if (input) {
      input.value = "";
      checkInput(input);
    }
    btn.textContent = "+ Betrag 2";
    updateDay(day);
  }
  // Nach √Ñnderung Betrag-2-Status Buttons neu bewerten
  updateAmount2ButtonsVisibility();
}


function toggleTipUI(btn){
  const wrapper = btn.parentElement.querySelector(".amountTip-wrapper");
  const input = wrapper ? wrapper.querySelector(".amountTip") : null;
  if (wrapper && input) {
    if (wrapper.style.display === "none" || wrapper.style.display === "") {
      // Feld einblenden
      wrapper.style.display = "block";
      btn.textContent = "‚àí TG";
      input.focus();
    } else {
      // Feld ausblenden und Wert l√∂schen
      wrapper.style.display = "none";
      input.value = "";
      checkInput(input);
      btn.textContent = "+ TG";
      const row = btn.closest("tr.entry-row");
      const day = getDayFromEntryRow(row);
      if (day !== null) {
        updateDay(day);
      }
    }
  }
  updateAmount2ButtonsVisibility();
}

let currentAmount1Row = null;

// Wird aufgerufen, wenn ein Betrag-1-Feld den Fokus erh√§lt.
// Merkt sich die aktuelle Zeile und aktualisiert die Sichtbarkeit
// der "+ Betrag 2"-Buttons.
function setCurrentAmount1Row(input){
  const row = input.closest("tr.entry-row");
  currentAmount1Row = row || null;
  updateAmount2ButtonsVisibility();
}

// Aktualisiert die Sichtbarkeit aller "+ Betrag 2"-Buttons.
// Grundlogik:
//  - Wenn in einer Zeile Betrag 2 bereits gef√ºllt/aktiv ist ‚Üí Button immer sichtbar.
//  - Sonst: Button nur in der aktuell fokussierten Zeile sichtbar.

function updateAmount2ButtonsVisibility(){
  const rows = document.querySelectorAll("tr.entry-row");
  rows.forEach(row => {
    const btn = row.querySelector(".toggle-amount2");
    const stdBtns = row.querySelectorAll(".std-amount-btn");
    const tipBtn = row.querySelector(".toggle-tip");

    // Betrag-2-Schalter: nur in der aktiven Zeile sichtbar
    if (btn) {
      if (row === currentAmount1Row) {
        btn.style.display = "inline-block";
      } else {
        btn.style.display = "none";
      }
    }

    // Standardbetrag-Buttons (22 / 33): alle in der aktiven Zeile sichtbar
    if (stdBtns && stdBtns.length) {
      stdBtns.forEach(stdBtn => {
        if (row === currentAmount1Row) {
          stdBtn.classList.add("visible");
        } else {
          stdBtn.classList.remove("visible");
        }
      });
    }

    // TG-Button: nur in der aktiven Zeile sichtbar
    if (tipBtn) {
      if (row === currentAmount1Row) {
        tipBtn.style.display = "inline-block";
      } else {
        tipBtn.style.display = "none";
      }
    }
  });
}


function handleEnter(e){
  // Auf Desktop funktioniert Enter normal, auf vielen Smartphones sendet die
  // Action-Taste der Bildschirmtastatur jedoch "Next"/Tab. Wir behandeln
  // deshalb sowohl Enter als auch Tab (keyCode 13 bzw. 9) als Ausl√∂ser.
  const k = e.key;
  const code = e.keyCode || e.which;
  const isActionKey = (k === "Enter" || k === "Tab" || code === 13 || code === 9);

  if(isActionKey){
    e.preventDefault();
    const currentRow = e.target.closest("tr.entry-row");
    if(!currentRow) return;
    const tbody = currentRow.parentElement;
    if(!tbody || !tbody.id || !tbody.id.startsWith("day-")) return;

    const rows = Array.from(tbody.querySelectorAll("tr.entry-row"));
    const idx = rows.indexOf(currentRow);
    if(idx === -1) return;

    // Wenn es eine weitere Zeile im selben Tag gibt ‚Üí dorthin springen
    if(idx < rows.length - 1){
      const nextRow = rows[idx + 1];
      const nextInput = nextRow.querySelector("input.amount1");
      if(nextInput){
        nextInput.focus();
        if(typeof nextInput.select === "function"){
          nextInput.select();
        }
      }
    } else {
      // Letzte Zeile dieses Tages: neue Zeile anlegen und dorthin springen
      const dayStr = tbody.id.split("-")[1];
      const day = parseInt(dayStr, 10);
      if(!isNaN(day)){
        addRow(day);
        const newRows = tbody.querySelectorAll("tr.entry-row");
        const lastRow = newRows[newRows.length - 1];
        const input = lastRow.querySelector("input.amount1");
        if(input){
          input.focus();
          if(typeof input.select === "function"){
            input.select();
          }
        }
      }
    }
  }
}

// Fallback speziell f√ºr Smartphones: Wenn der Benutzer das letzte
// Betragsfeld eines Tages verl√§sst und dort ein Wert steht, wird automatisch
// eine neue Zeile f√ºr diesen Tag angelegt.
function handleExit(e){
  // Fallback nur auf Touch-Ger√§ten aktivieren, damit auf Desktop
  // ein Mausklick auf eine freie Stelle keine neue, leere Zeile erzeugt.
  if (!isTouchDevice) return;
  const input = e.target;
  const currentRow = input.closest("tr.entry-row");
  if(!currentRow) return;
  const tbody = currentRow.parentElement;
  if(!tbody || !tbody.id || !tbody.id.startsWith("day-")) return;

  const rows = Array.from(tbody.querySelectorAll("tr.entry-row"));
  const idx = rows.indexOf(currentRow);
  if(idx === -1 || idx < rows.length - 1) return; // nicht letzte Zeile

  const a1 = currentRow.querySelector("input.amount1");
  const a2 = currentRow.querySelector("input.amount2");
  const hasValue =
    (a1 && a1.value !== "") ||
    (a2 && a2.value !== "");
  if(!hasValue) return; // Zeile leer ‚Üí nichts tun

  const dayStr = tbody.id.split("-")[1];
  const day = parseInt(dayStr, 10);
  if(isNaN(day)) return;

  addRow(day);
  const newRows = tbody.querySelectorAll("tr.entry-row");
  const lastRow = newRows[newRows.length - 1];
  const firstInput = lastRow.querySelector("input.amount1");
  if(firstInput){
    firstInput.focus();
    if(typeof firstInput.select === "function"){
      firstInput.select();
    }
  }
}

// Enter/Tab auch im Trinkgeld-Feld wie in Betrag 1/2 behandeln
document.addEventListener('keydown', function(e) {
  const t = e.target;
  if (t && t.classList && t.classList.contains('amountTip')) {
    handleEnter(e);
  }
});

// Eigene freie Tage speichern / lesen. Bei einem Klick kann der Benutzer w√§hlen,
// ob der Tag als Urlaubstag oder Krankheitstag markiert werden soll. Bei erneutem
// Klick wird die Markierung entfernt. Die Auswahl wird unter dem Schl√ºssel
// "cf-YYYY-MM-DD" im localStorage gespeichert und der Wert gibt die Art des
// freien Tages an ("urlaub" oder "krank").
function toggleFreeDay(day){
  const key = "cf-" + selYear + "-" + selMonth + "-" + day;
  const current = localStorage.getItem(key);

  let next;
  if(current === null){
    next = "urlaub";
  } else if(current === "urlaub"){
    next = "krank";
  } else if(current === "krank"){
    next = null;
  }

  if(next === null){
    localStorage.removeItem(key);
  } else {
    localStorage.setItem(key, next);
  }

  updateMonth();  // neu aufbauen
}

// Liefert den Typ des eigenen freien Tages ("urlaub", "krank") oder null, wenn
// der Tag kein eigener freier Tag ist.
function getFreeDayType(day){
  return localStorage.getItem("cf-" + selYear + "-" + selMonth + "-" + day);
}

// Pr√ºft, ob der Tag als eigener freier Tag markiert ist (unabh√§ngig vom Typ).
function isFreeDay(day){
  return getFreeDayType(day) !== null;
}

// Zus√§tzliche Helfer f√ºr die Erkennung fehlender Eintr√§ge im vorherigen Arbeitstag.

// Pr√ºft, ob ein bestimmter Tag (im aktuellen Monat) ein relevanter Arbeitstag ist,
// d.h. kein Wochenende, kein Feiertag und kein als frei (Urlaub/Krank) markierter Tag.
function isRelevantWorkday(day) {
  if (day < 1 || day > selDays) return false;
  const date = new Date(selYear, selMonth, day);
  const weekday = date.toLocaleDateString("de-DE", { weekday: "long" }).toLowerCase();
  if (weekday === "samstag" || weekday === "sonntag") return false;
  const ds = fmt(date);
  if (holidays && holidays[ds]) return false;
  if (isFreeDay(day)) return false;
  return true;
}

// Sucht den letzten relevanten Arbeitstag vor dem angegebenen Tag.
function findPreviousWorkday(currentDay) {
  for (let d = currentDay - 1; d >= 1; d--) {
    if (isRelevantWorkday(d)) return d;
  }
  return null;
}

// Pr√ºft, ob an dem angegebenen Tag mindestens ein Eintrag mit Betrag > 0 existiert.
function dayHasAnyEntry(day) {
  const tbody = document.getElementById("day-" + day);
  if (!tbody) return false;
  const rows = tbody.querySelectorAll("tr.entry-row");
  for (const row of rows) {
    const a1Str = row.querySelector(".amount1")?.value || "";
    const a2Str = row.querySelector(".amount2")?.value || "";
    const tipStr = row.querySelector(".amountTip")?.value || "";
    const num1 = parseFloat(String(a1Str).replace(",", "."));
    const num2 = parseFloat(String(a2Str).replace(",", "."));
    const numTip = parseFloat(String(tipStr).replace(",", "."));
    if ((!isNaN(num1) && num1 > 0) ||
        (!isNaN(num2) && num2 > 0) ||
        (!isNaN(numTip) && numTip > 0)) {
      return true;
    }
  }
  return false;
}

function hasAnyDataInMonth() {
  for (let d = 1; d <= selDays; d++) {
    if (dayHasAnyEntry(d)) return true;
  }
  return false;
}

function updateBackArrowLabel() {
  const wrapper = document.querySelector('.scroll-back-wrapper');
  if (!wrapper) return;
  const textSpan = wrapper.querySelector('.scroll-text');
  if (!textSpan) return;

  if (hasAnyDataInMonth()) {
    textSpan.textContent = " zum letzten Eintrag";
    wrapper.title = "Zum letzten Eintrag springen";
  } else {
    textSpan.textContent = " zur√ºck zum Start";
    wrapper.title = "Zur√ºck zum Start";
  }
}

let lastMissingDay = null;
let lastMissingHintRow = null;

// Zeigt einen Hinweis inline unter dem aktuellen Tag an, dass f√ºr einen
// vorherigen Tag keine Eintr√§ge vorhanden sind und bietet an, diesen
// als Urlaubstag / Krankheitstag zu markieren oder zu ihm zu springen.
// missingDay  = der Tag, an dem keine Eintr√§ge vorhanden sind
// currentDay  = der Tag, an dem gerade eine Eingabe vorgenommen wurde
function showMissingDayHint(missingDay, currentDay) {
  lastMissingDay = missingDay;

  // vorhandenen Inline-Hinweis entfernen
  hideMissingDayHint();

  const currentTbody = document.getElementById("day-" + currentDay);
  if (!currentTbody) return;

  const dateStr = String(missingDay).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;

  const tr = document.createElement("tr");
  tr.className = "missing-day-hint-inline-row";
  const td = document.createElement("td");
  td.colSpan = 5;
  td.innerHTML =
    '<div class="missing-day-hint-inline">' +
    'Hinweis: Am ' + dateStr + ' wurde kein Eintrag gemacht.<br/>' +
    '<button type="button" onclick="markMissingDayAs(\'urlaub\')">Als Urlaubstag markieren</button> ' +
    '<button type="button" onclick="markMissingDayAs(\'krank\')">Als Krankheitstag markieren</button>' +
    '</div>';
  tr.appendChild(td);

  // Hinweis direkt vor der Tagessummen-Zeile einf√ºgen, falls vorhanden
  const summaryRow = currentTbody.querySelector("tr.day-summary");
  if (summaryRow) {
    currentTbody.insertBefore(tr, summaryRow);
  } else {
    currentTbody.appendChild(tr);
  }

  lastMissingHintRow = tr;
}

function hideMissingDayHint() {
  if (lastMissingHintRow && lastMissingHintRow.parentNode) {
    lastMissingHintRow.parentNode.removeChild(lastMissingHintRow);
  }
  lastMissingHintRow = null;
}

// Markiert den zuletzt gemeldeten fehlenden Tag als Urlaub oder Krank
// und baut den Monat neu auf.
function markMissingDayAs(type) {
  if (!lastMissingDay) return;
  const key = "cf-" + selYear + "-" + selMonth + "-" + lastMissingDay;
  if (type === "urlaub" || type === "krank") {
    localStorage.setItem(key, type);
  }
  hideMissingDayHint();
  updateMonth();
}

// Scrollt zum zuletzt gemeldeten fehlenden Tag.
function scrollToMissingDay() {
  if (!lastMissingDay) return;
  const tbody = document.getElementById("day-" + lastMissingDay);
  if (!tbody) return;
  const rect = tbody.getBoundingClientRect();
  const target = rect.top + window.pageYOffset - 60;
  window.scrollTo({ top: target < 0 ? 0 : target, behavior: "smooth" });
}

// Wird nach der Aktualisierung eines Tages aufgerufen, um zu pr√ºfen,
// ob der vorherige relevante Arbeitstag leer ist.
function checkPreviousWorkdayForMissingEntries(day) {
  if (day <= 1) return;
  const prev = findPreviousWorkday(day);
  if (!prev) return;
  if (!dayHasAnyEntry(prev)) {
    showMissingDayHint(prev, day);
  } else if (lastMissingDay === prev) {
    // Falls der vorherige Tag inzwischen Eintr√§ge hat, Hinweis ggf. ausblenden
    hideMissingDayHint();
  }
}

// Monatsnavigation
function prevMonth(){
  selMonth--;
  if(selMonth < 0){ selMonth = 11; selYear--; }
  updateMonth();
}
function nextMonth(){
  selMonth++;
  if(selMonth > 11){ selMonth = 0; selYear++; }
  updateMonth();
}

function updateMonth(){
  document.getElementById("selected-month").innerText =
    monthNames[selMonth] + " " + selYear;

  selDays = daysInMonth(selYear, selMonth);
  holidays = getNRWHolidays(selYear);

  buildTable();
  loadAllDays();
  updateTotals();
  populateYearArchiveSelect();
}

// Tabelle aufbauen
function buildTable(){
  const table = document.getElementById("main-table");
  const tfoot = document.querySelector("tfoot");
  document.querySelectorAll("tbody.dayblock").forEach(e => e.remove());

  for(let day = 1; day <= selDays; day++){
    const date = new Date(selYear, selMonth, day);
    const weekday = date.toLocaleDateString("de-DE",{weekday:"long"}).toLowerCase();
    const weekdayLabel = weekday.charAt(0).toUpperCase() + weekday.slice(1);
    const ds = fmt(date);
    const isHoliday = (holidays[ds] != null);
    const isWeekend = (weekday === "samstag" || weekday === "sonntag");
    const isSunday  = (weekday === "sonntag");
    // Den Typ des eigenen freien Tages ermitteln ("urlaub", "krank" oder null)
    const freeType = getFreeDayType(day);
    const isFree = freeType !== null;

    let tb = document.createElement("tbody");
    tb.classList.add("dayblock");
    tb.id = "day-" + day;

    if(isHoliday){
      const holidayName = holidays[ds] || "Feiertag";
      tb.innerHTML = `<tr class="holiday">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${weekdayLabel} ‚Äì ${holidayName}</small></td>
        <td colspan="4">Kein Arbeitstag</td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else if(isWeekend){
      const weekendClass = isSunday ? "weekend sunday" : "weekend";
      tb.innerHTML = `<tr class="${weekendClass}">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${weekdayLabel}</small></td>
        <td colspan="4">Kein Arbeitstag</td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else if(isFree){
      // Je nach Typ des eigenen freien Tages eine passende Beschriftung w√§hlen
      const label = freeType === "urlaub"
        ? '<span class="label-urlaub">üå¥ Urlaubstag</span>'
        : (freeType === "krank"
           ? '<span class="label-krank">ü§í Krankheitstag</span>'
           : "Eigener freier Tag");
      // Bei eigenen freien Tagen soll die Beschriftung "Kein Arbeitstag" entfallen.
      tb.innerHTML = `<tr class="customfree">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${label}</small></td>
        <td colspan="4"></td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else {
      tb.innerHTML = `
        <tr class="entry-row">
          <td class="day-cell" onclick="toggleFreeDay(${day})">${day}</td>
          <td><div class="amount1-wrapper"><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 16, ${day})" title="16 ‚Ç¨ einf√ºgen">16</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 22, ${day})" title="22 ‚Ç¨ einf√ºgen">22</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 33, ${day})" title="33 ‚Ç¨ einf√ºgen">33</button><input class="amount1 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)"></div></td>
          <td>
            <div class="amount2-wrapper" style="display:none;">
              <input class="amount2 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)">
            </div>
            <button type="button" class="toggle-amount2" style="display:none;" onclick="toggleAmount2(this, ${day})">+ Betrag 2</button>
            
          </td>
          <td class="tg-cell">
                        <div class="amountTip-wrapper" style="display:none;">
              <input class="amountTip empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); (function(el){ const row = el.closest(\'tr.entry-row\'); const d = getDayFromEntryRow(row); if(d !== null){ updateDay(d); } })(this)">
            </div>
<button type="button" class="toggle-tip" style="display:none;" style="display:none;" onclick="toggleTipUI(this)">+ TG</button>
          </td>
          <td id="sum-${day}" class="scroll-to-summary"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    }
    table.insertBefore(tb, tfoot);
  }
}

function addRow(day){
  const tb = document.getElementById("day-" + day);
  const tr = document.createElement("tr");
  tr.classList.add("entry-row");
  tr.innerHTML = `
    <td></td>
    <td><div class="amount1-wrapper"><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 16, ${day})" title="16 ‚Ç¨ einf√ºgen">16</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 22, ${day})" title="22 ‚Ç¨ einf√ºgen">22</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 33, ${day})" title="33 ‚Ç¨ einf√ºgen">33</button><input class="amount1 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)"></div></td>
    <td>
      <div class="amount2-wrapper" style="display:none;">
        <input class="amount2 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)">
      </div>
      <button type="button" class="toggle-amount2" style="display:none;" onclick="toggleAmount2(this, ${day})">+ Betrag 2</button>
      
    </td>
    <td class="tg-cell">
                  <div class="amountTip-wrapper" style="display:none;">
              <input class="amountTip empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); (function(el){ const row = el.closest(\'tr.entry-row\'); const d = getDayFromEntryRow(row); if(d !== null){ updateDay(d); } })(this)">
            </div>
<button type="button" class="toggle-tip" style="display:none;" style="display:none;" onclick="toggleTipUI(this)">+ TG</button>
    </td>
    <td class="scroll-to-summary"></td>
    <td></td>`;
  const summary = tb.querySelector("tr.day-summary");
  if(summary){
    tb.insertBefore(tr, summary);
  } else {
    tb.appendChild(tr);
  }

  // Move the scroll indicator to the newly added row
  if (typeof updateScrollArrow === 'function') {
    updateScrollArrow(tr);
  }
}

// Schl√ºssel f√ºr localStorage
function dayKey(day){
  return "day-" + selYear + "-" + selMonth + "-" + day;
}

// Tag neu berechnen und speichern
function updateDay(day){
  // Berechne Summe und Kundenanzahl f√ºr den Tag
  let sum = 0;
  let customers = 0;
  document.querySelectorAll("#day-" + day + " .entry-row").forEach(row => {
    const a1 = parseFloat(row.querySelector(".amount1")?.value) || 0;
    const a2 = parseFloat(row.querySelector(".amount2")?.value) || 0;
    const tip = parseFloat(row.querySelector(".amountTip")?.value) || 0;
    if (a1 > 0 || a2 > 0 || tip > 0) customers++;
    sum += a1 + a2 + tip;
  });

  // Positioniere Summen- und Kunden-Zellen in der letzten Eintragszeile
  try {
    const tbody = document.getElementById("day-" + day);
    if (tbody) {
      const rows = tbody.querySelectorAll("tr.entry-row");
      if (rows && rows.length > 0) {
        const lastRow = rows[rows.length - 1];
        // Bisherige Summen- und Kundenzellen identifizieren und zur√ºcksetzen
        const currSumCell = document.getElementById("sum-" + day);
        const currCntCell = document.getElementById("cnt-" + day);
        if (currSumCell) {
          currSumCell.removeAttribute("id");
          currSumCell.classList.remove("scroll-to-summary");
          currSumCell.innerHTML = "";
        }
        if (currCntCell) {
          currCntCell.removeAttribute("id");
          currCntCell.innerText = "";
        }
        // Stelle sicher, dass die letzte Zeile mindestens 6 Zellen besitzt
        while (lastRow.children.length < 6) {
          const td = document.createElement("td");
          lastRow.appendChild(td);
        }
        // Setze neue IDs f√ºr Summe und Kunden in der letzten Zeile
        const newSumCell = lastRow.children[4];
        const newCntCell = lastRow.children[5];
        if (newSumCell) {
          newSumCell.id = "sum-" + day;
          newSumCell.classList.add("scroll-to-summary");
        }
        if (newCntCell) {
          newCntCell.id = "cnt-" + day;
        }
      }
    }
  } catch (e) {
    console.error("Fehler beim Verschieben der Summen-/Kunden-Zellen:", e);
  }

  // Aktualisiere den Text in den Summe- und Kundenzellen
  const sumCell = document.getElementById("sum-" + day);
  if (sumCell) {
    const sumSpan = sumCell.querySelector(".sum-value");
    const newText = sum > 0 ? sum.toFixed(2) : "";
    if (sumSpan) {
      sumSpan.textContent = newText;
    } else {
      sumCell.innerText = newText;
    }
  }
  const cntCell = document.getElementById("cnt-" + day);
  if (cntCell) {
    cntCell.innerText = customers > 0 ? customers : "";
  }

  saveDay(day);
  updateTotals();
  // Pr√ºfe vorherigen Arbeitstag auf fehlende Eintr√§ge, wenn Summe vorhanden ist
  if (sum > 0) {
    checkPreviousWorkdayForMissingEntries(day);
  }
  // Hinweis ausblenden, wenn der zuletzt gemeldete fehlende Tag nun einen Eintrag hat
  if (typeof lastMissingDay !== "undefined" && lastMissingDay === day) {
    if (dayHasAnyEntry(day)) {
      hideMissingDayHint();
    }
  }
}

function saveDay(day){
  const rows = [...document.querySelectorAll("#day-" + day + " .entry-row")].map(row => ({
    amount1: row.querySelector(".amount1")?.value || "",
    amount2: row.querySelector(".amount2")?.value || "",
    amountTip: row.querySelector(".amountTip")?.value || ""
  }));
  localStorage.setItem(dayKey(day), JSON.stringify(rows));
}

function loadDay(day){
  const raw = localStorage.getItem(dayKey(day));
  if(!raw) return;
  const rows = JSON.parse(raw);
  const tb = document.getElementById("day-" + day);
  if(!tb) return;

  rows.forEach((r, idx) => {
    if(idx > 0) addRow(day);
    const row = tb.querySelectorAll(".entry-row")[idx];
    const a1 = row.querySelector(".amount1");
    const a2 = row.querySelector(".amount2");
    const tip = row.querySelector(".amountTip");
    const wrapper = row.querySelector(".amount2-wrapper");
    const toggleBtn = row.querySelector(".toggle-amount2");
    const tipWrapper = row.querySelector(".amountTip-wrapper");
    const tipBtn = row.querySelector(".toggle-tip");

    // Kompatibilit√§t: sowohl amount1/amount2 als auch a1/a2 akzeptieren
    a1.value = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
    a2.value = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
    if (tip) {
      tip.value = r.amountTip !== undefined ? r.amountTip : "";
    }

    checkInput(a1);
    checkInput(a2);
    if (tip) checkInput(tip);

    if(wrapper){
      if(a2.value !== ""){
        wrapper.style.display = "block";
        if(toggleBtn) toggleBtn.textContent = "‚àí Betrag 2";
      } else {
        wrapper.style.display = "none";
        if(toggleBtn) toggleBtn.textContent = "+ Betrag 2";
      }
    }

    if (tipWrapper && tip) {
      if (tip.value !== "") {
        tipWrapper.style.display = "block";
        if (tipBtn) tipBtn.textContent = "‚àí TG";
      } else {
        tipWrapper.style.display = "none";
        if (tipBtn) tipBtn.textContent = "+ TG";
      }
    }
  });

  updateDay(day);
}

function loadAllDays(){
  for(let d = 1; d <= selDays; d++){
    loadDay(d);
  }
  // Nach dem Laden aller Tage Buttons f√ºr Betrag 2 korrekt initialisieren
  updateAmount2ButtonsVisibility();
}

// Gesamtsummen
function updateTotals(){
  let total = 0;
  let totalCustomers = 0;
  let totalWorkdays = 0;

  for(let d = 1; d <= selDays; d++){
    const s = parseFloat(document.getElementById("sum-" + d)?.innerText) || 0;
    const c = parseInt(document.getElementById("cnt-" + d)?.innerText) || 0;
    total += s;
    totalCustomers += c;
    if (c > 0) totalWorkdays++;
  }

  document.getElementById("grand-total").innerText = total.toFixed(2);

  const grandCustomersEl = document.getElementById("grand-customers");
  if (grandCustomersEl) grandCustomersEl.innerText = totalCustomers;

  const grandWorkdaysEl = document.getElementById("grand-workdays");
  if (grandWorkdaysEl) grandWorkdaysEl.innerText = totalWorkdays;

  const net = total / 1.19;
  document.getElementById("net-total").innerText = net.toFixed(2);
  document.getElementById("tax-total").innerText = (total - net).toFixed(2);

  // Beschriftung des Zur√ºck-Pfeils abh√§ngig davon, ob Daten vorhanden sind
  updateBackArrowLabel();
}

// JSON Export / Import
function exportJSON(){
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {}
  };

  for(let d = 1; d <= selDays; d++){
    const key = dayKey(d);
    const raw = localStorage.getItem(key);
    if(raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if(freeVal) data.free[cf] = freeVal;
  }

  // Standard-Dateinamen vorschlagen
  const defaultName = "einnahmen_" + selYear + "-" + String(selMonth+1).padStart(2,"0") + ".json";

  // Hinweis, wo gespeichert wird, und M√∂glichkeit zur Umbenennung
  const message = "Die Datei wird in Ihrem Standard-Download-Ordner gespeichert (z.B. 'Downloads').\n\n"
    + "Vorgeschlagener Dateiname:\n" + defaultName + "\n\n"
    + "Sie k√∂nnen den Dateinamen hier √§ndern oder einfach mit OK best√§tigen.";

  // In einigen Offline-Umgebungen ist die prompt-Funktion deaktiviert.
  // Daher speichern wir ohne R√ºckfrage mit dem vorgeschlagenen Dateinamen.
  let filename = defaultName;
  if (!filename.toLowerCase().endsWith(".json")) {
    filename += ".json";
  }
const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function importJSON(ev){
  const file = ev.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try{
      const data = JSON.parse(e.target.result);
      if(data.days){
        for(const key in data.days){
          localStorage.setItem(key, JSON.stringify(data.days[key]));
        }
      }
      if(data.free){
        for(const key in data.free){
          const val = data.free[key];
          // √Ñltere Exporte speicherten nur "1" ‚Üí standardm√§√üig als "urlaub" interpretieren
          if(val === 1 || val === "1" || val === true){
            localStorage.setItem(key, "urlaub");
          } else if(val === "urlaub" || val === "krank") {
            localStorage.setItem(key, val);
          } else {
            // Unbekannte Werte ebenfalls als Urlaub behandeln, damit zyklisches Umschalten funktioniert
            localStorage.setItem(key, "urlaub");
          }
        }
      }
      /* Import ohne Reload: UI sofort aktualisieren */
      // Optional: nach Import auf den importierten Monat springen
      if (data && data.year != null && !Number.isNaN(Number(data.year))) selYear = Number(data.year);
      if (data && data.month != null && !Number.isNaN(Number(data.month))) selMonth = Number(data.month);

      // Sperrstatus: wenn im Import nicht vorhanden, Monat entsperren (stale locks vermeiden)
      const importedLocked = (data && Object.prototype.hasOwnProperty.call(data, "locked"))
        ? (data.locked === true || data.locked === 1 || data.locked === "1")
        : false;
      if (typeof setMonthLocked === "function") {
        setMonthLocked(selYear, selMonth, importedLocked);
      } else if (importedLocked) {
        localStorage.setItem(`locked-${selYear}-${selMonth}`, "1");
      } else {
        localStorage.removeItem(`locked-${selYear}-${selMonth}`);
      }

      try { hideMissingDayHint(); } catch(e) {}
      try { updateMonth(); } catch(e) { console.error(e); }
      try { applyLockStatus(); } catch(e) {}
      alert("Import erfolgreich.");
      try { ev.target.value = ""; } catch(e) {}
      try { if (typeof refocusAfterNativeDialogs === 'function') refocusAfterNativeDialogs(); } catch(e) {}
    }catch(err){
      alert("Fehler beim Import: " + err.message);
    }
  };
  reader.readAsText(file);
}

// Alle gespeicherten Daten l√∂schen
function clearAllData(){
  // Hinweis mit Backup-Info und Bezug auf den aktuellen Monat
  const monthLabel = (selMonth + 1).toString().padStart(2, "0") + "." + selYear;
  const confirmMsg =
    "Es wird jetzt eine Sicherungsdatei f√ºr den aktuell ausgew√§hlten Monat (" + monthLabel + ") erstellt,\n" +
    "und anschlie√üend werden alle Daten dieses Monats gel√∂scht.\n\n" +
    "Fortfahren?";

  if (!confirm(confirmMsg)) {
    return;
  }

  // Zuerst automatische Sicherung des aktuellen Monats als JSON
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {}
  };

  for (let d = 1; d <= selDays; d++) {
    const key = dayKey(d);
    const raw = localStorage.getItem(key);
    if (raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if (freeVal) data.free[cf] = freeVal;
  }

  const backupName = "backup_einnahmen_" +
    selYear + "-" + String(selMonth + 1).padStart(2, "0") + ".json";

  try {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = backupName;
    a.click();
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error("Backup konnte nicht erstellt werden:", e);
  }

  // Danach nur die Daten des aktuellen Monats aus dem Speicher entfernen
  for (let d = 1; d <= selDays; d++) {
    const key = dayKey(d);
    localStorage.removeItem(key);
    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    localStorage.removeItem(cf);
  }
  localStorage.removeItem("totalTip");

  alert("Backup erstellt. Alle Daten f√ºr den Monat " + monthLabel + " wurden gel√∂scht.");
  try { hideMissingDayHint(); } catch(e) {}
  try { updateMonth(); } catch(e) {}
  try { applyLockStatus(); } catch(e) {}
  try { if (typeof refocusAfterNativeDialogs === 'function') refocusAfterNativeDialogs(); } catch(e) {}
}



// CSV Export
function exportCSV(){
  let lines=["Tag;Betrag1;Betrag2"];
  for(let d=1; d<=selDays; d++){
    let rows = document.querySelectorAll("#day-"+d+" .entry-row");
    rows.forEach(r=>{
      let a1 = r.querySelector(".amount1")?.value || "";
      let a2 = r.querySelector(".amount2")?.value || "";
      lines.push(`${d};${a1};${a2}`);
    });
  }
  let blob=new Blob([lines.join("\n")],{type:"text/csv"});
  let url=URL.createObjectURL(blob);
  let a=document.createElement("a");
  a.href=url;
  a.download="einnahmen.csv";
  a.click();
  URL.revokeObjectURL(url);
}



// ======================
// Jahresarchiv (Backup)
// ======================

// Ermittelt alle Jahre, die aktuell im localStorage vorkommen (day-/cf-/locked-Keys)
function getArchiveYearsFromStorage(){
  const years = new Set();
  try{
    for(let i = 0; i < localStorage.length; i++){
      const k = localStorage.key(i);
      if(!k) continue;
      const m = k.match(/^(day|cf|locked)-(\d{4})-/);
      if(m) years.add(parseInt(m[2], 10));
    }
  } catch(e){}
  if(typeof selYear === "number") years.add(selYear);
  return Array.from(years).filter(y => !isNaN(y)).sort((a,b) => b-a);
}

function populateYearArchiveSelect(){
  const sel = document.getElementById("year-archive-select");
  if(!sel) return;
  const years = getArchiveYearsFromStorage();
  sel.innerHTML = "";
  years.forEach(y => {
    const opt = document.createElement("option");
    opt.value = String(y);
    opt.textContent = String(y);
    if (typeof selYear === "number" && y === selYear) opt.selected = true;
    sel.appendChild(opt);
  });
  // Falls noch kein Jahr vorhanden ist, wenigstens aktuelles Jahr anbieten
  if(!sel.options.length && typeof selYear === "number"){
    const opt = document.createElement("option");
    opt.value = String(selYear);
    opt.textContent = String(selYear);
    sel.appendChild(opt);
  }
}

function _getSelectedArchiveYear(){
  const sel = document.getElementById("year-archive-select");
  const y = sel ? parseInt(sel.value, 10) : NaN;
  return (!isNaN(y) ? y : selYear);
}

function _buildYearArchiveData(year){
  const data = {
    app: "Einnahmen",
    version: "V267.02.26",
    year: year,
    createdAt: new Date().toISOString(),
    days: {},
    free: {},
    locked: {}
  };

  for(let i = 0; i < localStorage.length; i++){
    const k = localStorage.key(i);
    if(!k) continue;

    if(k.startsWith(`day-${year}-`)){
      const raw = localStorage.getItem(k);
      if(raw){
        try { data.days[k] = JSON.parse(raw); }
        catch(e){ data.days[k] = raw; }
      }
    } else if(k.startsWith(`cf-${year}-`)){
      const v = localStorage.getItem(k);
      if(v != null) data.free[k] = v;
    } else if(k.startsWith(`locked-${year}-`)){
      // lock key: locked-YYYY-M
      const v = localStorage.getItem(k);
      if(v != null) data.locked[k] = v;
    }
  }
  return data;
}

async function _downloadJsonData(data, defaultName, promptMessage){
  // JSON-Text vorbereiten
  const jsonText = JSON.stringify(data, null, 2);
  const baseName = (defaultName || "backup.json").trim() || "backup.json";
  const ensureJsonExt = (name) => {
    let n = (name || "").trim();
    if (!n) n = baseName;
    if (!n.toLowerCase().endsWith(".json")) n += ".json";
    return n;
  };

  // 1) Desktop-App (Electron): nativer ‚ÄûSpeichern unter‚Ä¶‚Äú-Dialog + Schreiben via electronAPI
  try{
    if (window.electronAPI && typeof window.electronAPI.saveBinaryFile === "function"){
      const result = await window.electronAPI.saveBinaryFile({
        title: "Backup speichern",
        defaultName: ensureJsonExt(baseName),
        filters: [{ name: "JSON-Datei", extensions: ["json"] }],
        data: jsonText,
        encoding: "utf8"
      });
      return !!(result && !result.canceled);
    }
  }catch(e){
    console.warn("JSON-Speichern (Desktop) fehlgeschlagen ‚Äì Fallback auf Browser-Download.", e);
    try{ alert("Desktop-Speichern ist fehlgeschlagen. Es wird der Browser-Download versucht.\n\nDetails: " + (e && e.message ? e.message : e)); }catch(_){ }
  }

  // 2) Browser: In manchen Offline-Umgebungen ist die prompt-Funktion deaktiviert.
  // Daher verwenden wir ohne R√ºckfrage den vorgeschlagenen Dateinamen.
  let filename = ensureJsonExt(baseName);
const blob = new Blob([jsonText], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
  return true;
}

// Manuelles Jahres-Backup (nur speichern)
async function exportYearArchive(){
  const year = _getSelectedArchiveYear();
  try{
    const data = _buildYearArchiveData(year);
    const defaultName = `einnahmen_${year}_gesamt.json`;
    const msg =
      "Jahres-Backup f√ºr " + year + "\n\n" +
      "Wenn Sie die Desktop-App nutzen, erscheint ein \"Speichern unter‚Ä¶\"-Dialog.\n" +
      "Im Browser wird die Datei in den Download-Ordner geladen.\n\n" +
      "Vorgeschlagener Dateiname:\n" + defaultName + "\n\n" +
      "Sie k√∂nnen den Dateinamen hier √§ndern oder einfach mit OK best√§tigen.";
    const ok = await _downloadJsonData(data, defaultName, msg);
    if(!ok){
      alert("Jahres-Backup wurde abgebrochen oder konnte nicht gespeichert werden.");
    }
  }catch(err){
    alert("Fehler beim Jahres-Backup: " + (err && err.message ? err.message : err));
    console.error(err);
  }
}

// Jahres-Backup laden (Restore)
function importYearArchive(ev){
  const file = ev?.target?.files?.[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try{
      const data = JSON.parse(e.target.result);

      // Unterst√ºtzt Struktur: {year, days, free, locked}
      // und optional: {years: { "2025": {days, free, locked} } }
      let payload = data;
      if (data && data.years && typeof data.years === "object") {
        const yearKey = String(_getSelectedArchiveYear());
        payload = data.years[yearKey] || data.years[Object.keys(data.years)[0]];
      }

      if(payload && payload.days){
        for(const key in payload.days){
          localStorage.setItem(key, JSON.stringify(payload.days[key]));
        }
      }
      if(payload && payload.free){
        for(const key in payload.free){
          const val = payload.free[key];
          if(val === 1 || val === "1" || val === true){
            localStorage.setItem(key, "urlaub");
          } else if(val === "urlaub" || val === "krank") {
            localStorage.setItem(key, val);
          } else if(val != null) {
            localStorage.setItem(key, String(val));
          }
        }
      }
      if(payload && payload.locked){
        for(const key in payload.locked){
          const v = payload.locked[key];
          if(v === "1" || v === 1 || v === true){
            localStorage.setItem(key, "1");
          } else {
            localStorage.removeItem(key);
          }
        }
      }

      alert("Jahres-Import erfolgreich.");
      try { hideMissingDayHint(); } catch(e) {}
      try { updateMonth(); } catch(e) { console.error(e); }
      try { populateYearArchiveSelect(); } catch(e) {}
    } catch(err){
      alert("Fehler beim Jahres-Import: " + err.message);
    }
  };
  reader.readAsText(file);

  // Input zur√ºcksetzen, damit die gleiche Datei erneut gew√§hlt werden kann
  try { ev.target.value = ""; } catch(e) {}
}

// Backup + L√∂schen f√ºr ein komplettes Jahr
async function archiveAndDeleteYear(){
  const year = _getSelectedArchiveYear();

  const confirmMsg =
    "Es wird zuerst ein Jahres-Backup f√ºr das Jahr " + year + " erstellt,\n" +
    "und anschlie√üend werden alle Daten dieses Jahres gel√∂scht.\n\n" +
    "Fortfahren?";
  if(!confirm(confirmMsg)) return;

  const data = _buildYearArchiveData(year);
  const defaultName = `einnahmen_${year}_gesamt.json`;
  const msg =
    "Backup-Dateiname f√ºr das Jahr " + year + ":\n\n" +
    defaultName + "\n\n" +
    "Nach dem Speichern werden alle Daten dieses Jahres gel√∂scht.\n\n" +
    "OK = Speichern & L√∂schen, Abbrechen = nichts tun";
  const ok = await _downloadJsonData(data, defaultName, msg);
  if(!ok) return;

  // Schl√ºssel sammeln (nicht w√§hrend des Iterierens l√∂schen)
  const keysToRemove = [];
  for(let i = 0; i < localStorage.length; i++){
    const k = localStorage.key(i);
    if(!k) continue;
    if(k.startsWith(`day-${year}-`) || k.startsWith(`cf-${year}-`) || k.startsWith(`locked-${year}-`)){
      keysToRemove.push(k);
    }
  }
  keysToRemove.forEach(k => localStorage.removeItem(k));

  alert("Backup gespeichert. " + keysToRemove.length + " Eintr√§ge f√ºr " + year + " wurden gel√∂scht.");

  // UI aktualisieren
  if(typeof updateMonth === "function"){
    updateMonth();
  } else {
    populateYearArchiveSelect();
  }
}

</script>
<style>
/*
 * Im Druckmodus wird nur der Bereich "#reduced-print" ausgegeben. Auf einigen
 * Mobilger√§ten kann "visibility: hidden" dazu f√ºhren, dass leere Seiten
 * entstehen, da der verborgene Inhalt weiterhin Platz reserviert. Daher
 * verwenden wir "display: none" f√ºr alle Elemente au√üer dem Ausdrucksbereich
 * und blenden diesen explizit √ºber "display: block" ein. Zus√§tzlich sorgen
 * wir f√ºr eine klare Formatierung (monospace‚ÄëSchrift) und setzen Farbe und
 * Hintergrund, damit die PDF‚ÄëDarstellung auf Smartphones korrekt ist.
 */
@media print {
  /* Alle Elemente standardm√§√üig ausblenden */
  body * {
    display: none !important;
  }

  /* Ausdrucksbereich sichtbar machen */
  #reduced-print {
    display: block !important;
    position: absolute;
    left: 0;
    top: 0;
    font-size: 12pt;
    color: black !important;
    background: white !important;
    white-space: pre !important;
  }

  /* Monospace im Ausdruck erzwingen (wichtig f√ºr b√ºndige Spalten) */
  #reduced-print, #reduced-print * {
    font-family: "Courier New", Courier, monospace !important;
    font-weight: 600 !important;
  }

  /* Pre-Layout beibehalten */
  #reduced-print pre {
    display: block !important;
    margin: 0 !important;
    white-space: pre !important;
  }

  /* √úberschriften-Spans inline halten */
  #reduced-print pre span {
    display: inline !important;
  }

  #reduced-print .print-heading {
    font-weight: 800 !important;
  }
}

/* √Ñu√üerer Rahmen pro Tag */
tbody[id^="day-"] {
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 10px;
  border-collapse: separate;
  border-spacing: 0;
}

/* Keine Rahmen innerhalb eines Tagesblocks */
tbody[id^="day-"] td,
tbody[id^="day-"] tr {
  border: none !important;
  outline: none !important;
}

/* Inputs bleiben sichtbar, aber dezent */
tbody[id^="day-"] input {
  border: 1px solid #ccc;
}


/* Gr√∂√üere Darstellung der Tageszahlen (erste Spalte) */
tbody[id^="day-"] tr:first-child td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Auch Tageszahlen in freien Tagen (z.‚ÄØB. Samstag, Sonntag, Feiertag) gr√∂√üer darstellen */
tr.frei td span.fett {
  font-size: 1.4em;
}


/* Auch regul√§re Tageszahlen gr√∂√üer darstellen */
tbody[id^="day-"] tr td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Tagessumme (rechts unten) und Kundenanzahl fett */
tbody[id^="day-"] tr:last-child td:last-child,
tbody[id^="day-"] tr:last-child td:nth-last-child(2) {
  font-weight: bold;
}

</style>
</head>
<body class="bg-darkblue" onload="updateMonth()">
<div class="container">
<h1>Einnahmen V267.02.26 </h1>
<div id="month-nav">
<button class="nav-btn" onclick="prevMonth()">‚óÑ</button>
<span id="selected-month"></span><span id="month-lock-toggle" onclick="toggleLock()" style="cursor:pointer; font-size: 1.4em; margin-left: 10px;" title="Monat bearbeiten/sperren">üîì</span>
<button class="nav-btn" onclick="nextMonth()">‚ñ∫</button>
</div>
<table id="main-table">
<thead>
<tr>
<th>Tag</th>
<th>Betrag 1</th>
<th>Betrag 2</th><th>TG</th>
<th>Summe</th>
<th>Kunden</th>
</tr>
</thead>
<tfoot></tfoot>
<tr>
<!-- Beschriftung links und Gesamtzahl der Kunden in der letzten Spalte -->
<!-- Der Text "Gesamtanzahl¬†Kunden:" wird bewusst etwas kleiner dargestellt, bleibt aber schwarz -->
<td colspan="5" style="text-align: right;
             font-weight: normal;
             color: #000;
             font-size: 0.8em;
             font-style: italic;">
    Gesamtanzahl¬†Kunden:
  </td>
<td id="grand-customers" style="font-weight: bold;">0</td>
</tr>
<tr>
<!-- Beschriftung links und Gesamtzahl der Arbeitstage in der letzten Spalte -->
<td colspan="5" style="text-align: right;
             font-weight: normal;
             color: #000;
             font-size: 0.8em;
             font-style: italic;">
    Gesamtanzahl¬†Arbeitstage:
  </td>
<td id="grand-workdays" style="font-weight: bold;">0</td>
</tr>
</table>
<div style="margin-top:20px;">
<div id="primary-controls" style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
<button class="modern-btn" onclick="generateReducedPrint()">üñ®Ô∏è Reduzierter Druck</button>
<button class="modern-btn" onclick="exportJSON()">Datei speichern</button>
</div>
<!-- Schnell-Zur√ºck: immer sichtbar -->
<div style="margin-top:4px; text-align:right; padding-right:10px;">
<span class="scroll-back-wrapper" title="Zum letzten Eintrag springen">
<span class="scroll-circle">‚Üë</span><span class="scroll-text"> zum letzten Eintrag</span>
</span>
</div>
<div id="advanced-controls" style="display:none; margin-top:10px;">
<input accept="application/json" id="data-file-input" onchange="importJSON(event)" style="display:none;" type="file"/>
<button onclick="document.getElementById('data-file-input').click()">Datei laden</button>
<div style="display:inline-block; margin-left:10px;">
<button onclick="clearAllData()">Alle Daten l√∂schen</button>
</div>
<div style="margin-top:12px; padding-top:10px; border-top:1px dashed #666;">
<div style="margin-bottom:6px; font-weight:bold;">Jahresarchiv</div>
<label for="year-archive-select">Jahr:</label>
<select id="year-archive-select"></select>
<div style="display:inline-block; margin-left:10px;">
<button class="modern-btn" onclick="exportYearArchive()">üíæ Jahres-Backup speichern</button>
<br/>
<button class="modern-btn" onclick="archiveAndDeleteYear()" style="margin-top:6px;">üßπ Jahr archivieren &amp; l√∂schen</button>
</div>
<div style="display:inline-block; margin-left:10px;">
<input accept="application/json" id="year-archive-input" onchange="importYearArchive(event)" style="display:none;" type="file"/>
<button onclick="document.getElementById('year-archive-input').click()">Jahres-Backup laden</button>
</div>
</div>
<div style="margin-top:10px;">
<label for="quarter-select">Quartal:</label>
<select id="quarter-select">
<option value="1">Q1 (Jan‚ÄìM√§r)</option>
<option value="2">Q2 (Apr‚ÄìJun)</option>
<option value="3">Q3 (Jul‚ÄìSep)</option>
<option value="4">Q4 (Okt‚ÄìDez)</option>
</select>
<div style="display:inline-block; margin-left:10px;">
<button class="modern-btn" onclick="generateQuarterReducedPrint()">üñ®Ô∏è Quartal drucken</button>
<br/>
<button class="modern-btn" onclick="generateYearOverview()" style="margin-top:6px;">üßÆ Jahres√ºbersicht drucken</button>
</div>
<div style="display:inline-block; margin-left:10px;">
<button class="excel-btn" onclick="exportQuarterExcel()">üìä Quartal Excel</button>
<br/>
<button class="excel-btn" onclick="exportExcel()" style="margin-top:6px;">üìä Excel speichern</button>
</div>
</div>
</div>
<div id="admin-code-wrapper" style="margin-top:8px; text-align:right; padding-right:10px;">
<label for="unlock-code" style="font-size:0.9em; font-weight:bold;">Code:</label>
<input autocomplete="off" id="unlock-code" inputmode="numeric" maxlength="4" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" style="width:90px; text-align:center; margin-left:6px; padding:4px 6px;" type="password"/>
<span style="font-size:0.85em; margin-left:6px; opacity:0.85;">(weitere Funktionen)</span>
</div>
</div>
<div id="onscreen-totals" style="margin-top:20px;">
<h3>Monats√ºbersicht</h3>
<table>
<tr><th>Gesamtsumme</th><td id="grand-total"></td></tr>
<tr><th>Netto</th><td id="net-total"></td></tr>
<tr><th>MwSt</th><td id="tax-total"></td></tr>
</table>
</div>
<div class="print-summary" style="display:none;">
<h3>Monats√ºbersicht (Druck)</h3>
<table>
<tr><th>Gesamtsumme</th><td id="grand-total-print"></td></tr>
<tr><th>Netto</th><td id="net-total-print"></td></tr>
<tr><th>MwSt</th><td id="tax-total-print"></td></tr>
</table>
</div>
</div>
<div id="reduced-print" style="display:none;"></div>
<script>
/**
 * Erzeugt einen einfachen Ausdruck der Tages- und Monats√ºbersicht.
 * Diese Funktion sammelt alle Eintr√§ge, summiert sie, erzeugt eine
 * textbasierte Tabelle und √∂ffnet den Browser-Druckdialog. Es wird
 * au√üerdem die Gesamtanzahl aller Kunden am Monatsende ausgegeben.
 */

function getSelectedQuarter() {
  const sel = document.getElementById("quarter-select");
  let q = sel ? parseInt(sel.value, 10) : NaN;
  if (!(q >= 1 && q <= 4)) {
    q = Math.floor(selMonth / 3) + 1;
  }
  return q;
}

function getQuarterMonths(q) {
  const start = (q - 1) * 3;
  return [start, start + 1, start + 2];
}


// Hilfsfunktionen f√ºr den Druck: Text sicher in HTML umwandeln und √úberschriften fett darstellen
function _escapeHtmlForPrint(str) {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/**
 * Setzt den Inhalt des Druckbereichs als HTML, damit √úberschriften wirklich fett sein k√∂nnen.
 * Der eigentliche Inhalt bleibt monospace + whitespace-pre, damit die Ausrichtung stimmt.
 */
function setReducedPrintHtmlFromText(text) {
  const rp = document.getElementById("reduced-print");
  if (!rp) return;

  let esc = _escapeHtmlForPrint(text);

  // √úberschriftenzeilen fett markieren (Monat / Quartal / Jahr)
  esc = esc
    .replace(/^Einnahmen .*$/gm, '<span class="print-heading">$&</span>')
    .replace(/^Monats√ºbersicht.*$/gm, '<span class="print-heading">$&</span>')
    .replace(/^Quartals√ºbersicht.*$/gm, '<span class="print-heading">$&</span>')
    .replace(/^Jahresgesamt .*$/gm, '<span class="print-heading">$&</span>');

  rp.innerHTML = "<pre>" + esc + "</pre>";
}

function generateQuarterReducedPrint() {
  const q = getSelectedQuarter();
  const months = getQuarterMonths(q);
  const year = selYear;
  let output = "";
  let total = 0;
  let totalCustomers = 0;
  let totalWorkdays = 0;
  let printedTotal = 0;

  const labelWidth = 26;
  // Breite der Datumsspalte f√ºr Tageszeilen. Durch die Angleichung an
  // labelWidth erscheinen die Betr√§ge der Tageszeilen und der
  // Monats- bzw. Quartalssummen b√ºndig untereinander.
  const datePadWidth = labelWidth;
  function line(label, value) {
    return label.padEnd(labelWidth) + value.toFixed(2).replace(".", ",").padStart(10) + "\n\n";
  }

  months.forEach(m => {
    output += "Einnahmen " + monthNames[m] + " " + year + "\n\n";
    const days = daysInMonth(year, m);

    let monthTotal = 0;
    let monthCustomers = 0;
    let monthWorkdays = 0;
    let monthPrintedTotal = 0;

    for (let d = 1; d <= days; d++) {
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      const freeKey = "cf-" + year + "-" + m + "-" + d;
      const freeType = localStorage.getItem(freeKey);

      const hasEntries = rows && rows.some(r => {
        const a1 = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
        const a2 = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
        const tip = r.amountTip !== undefined ? r.amountTip : "";
        return (a1 && parseFloat(String(a1).replace(",", ".")) > 0) ||
               (a2 && parseFloat(String(a2).replace(",", ".")) > 0) ||
               (tip && parseFloat(String(tip).replace(",", ".")) > 0);
      });

      if (freeType) {
        const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank" ? "Krankheitstag" : "Eigener freier Tag");
        output += dateStr.padEnd(datePadWidth) + label + "\n\n";
        continue;
      }

      let tagSum = 0;
      let kunden = 0;
      let zeilen = [];
    let zeilenDetails = [];

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));
          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);
          if (sumVal > 0) {
            kunden++;
            const fmt = n => n.toFixed(2).replace(".", ",");
            const formattedSum = fmt(sumVal);
            const fmt1 = !isNaN(num1) ? fmt(num1) : "";
            const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
            const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";
            let parts = [];
            if (fmt1) parts.push(fmt1);
            if (fmt2) parts.push(fmt2);
            if (fmtTip) parts.push(fmtTip);
            let line;
            if (parts.length > 1) {
              line = formattedSum.padStart(10) + "   " + parts.join(" + ");
            } else {
              line = formattedSum.padStart(10);
            }
            zeilen.push(line);
            zeilenDetails.push(parts.length > 1 ? parts.join(" + ") : "");
            tagSum += sumVal;
          }
        });
      }

      if (tagSum > 0) {
        const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
const kundenLabel = (kunden === 1 ? "Kunde" : "Kunden");

if (kunden === 1) {
  const detailAfter = (zeilenDetails[0] ? "   " + zeilenDetails[0] : "");
  output += dateStr.padEnd(datePadWidth)
    + tagSum.toFixed(2).replace(".", ",").padStart(10)
    + "   |   1 " + kundenLabel
    + detailAfter
    + "\n\n";
} else {

  const maxLines = Math.max(zeilen.length, 1);
  for (let i = 0; i < maxLines; i++) {
    const datum = i === 0 ? dateStr.padEnd(datePadWidth) : " ".repeat(datePadWidth);
    const einnahme = zeilen[i] || "";
    output += datum + einnahme + "\n";
  }
  output += " ".repeat(datePadWidth) + "----------\n";
  output += " ".repeat(datePadWidth)
    + tagSum.toFixed(2).replace(".", ",").padStart(10)
    + "   |   " + kunden + " " + kundenLabel + "\n\n";
}

        const roundedDay = Math.round(tagSum * 100) / 100;
        printedTotal += roundedDay;
        total += tagSum;
        totalCustomers += kunden;
        totalWorkdays += 1;

        monthPrintedTotal += roundedDay;
        monthTotal += tagSum;
        monthCustomers += kunden;
        monthWorkdays += 1;
      }
    }

    // Monats√ºbersicht (nach jedem Monat)
    const nettoM = monthTotal / 1.19;
    const mwstM = monthTotal - nettoM;
    const roundedMonth = Math.round(monthPrintedTotal * 100) / 100;
    const roundingDiffM = Math.round((roundedMonth - monthTotal) * 100) / 100;

    output += "Monats√ºbersicht (" + monthNames[m] + " " + year + ")\n\n";
    output += line("Summe Tagessummen:", roundedMonth);
    output += line("Exakte Gesamtsumme:", monthTotal);
    output += line("Rundungsdifferenz:", roundingDiffM);
    output += line("Netto:", nettoM);
    output += line("MwSt (19%):", mwstM);
    output += ("Gesamtanzahl Kunden:".padEnd(labelWidth) + String(monthCustomers).padStart(10) + "\n\n");

        output += ("Gesamtanzahl Arbeitstage:".padEnd(labelWidth) + String(monthWorkdays).padStart(10) + "\n\n");
output += "\n";
  });

  const netto = total / 1.19;
  const mwst = total - netto;
  const roundedTotal = Math.round(printedTotal * 100) / 100;
  const roundingDiff = Math.round((roundedTotal - total) * 100) / 100;

  output += "Quartals√ºbersicht (Q" + q + " " + year + ")\n";
  output += line("Summe Tagessummen:", roundedTotal);
  output += line("Exakte Gesamtsumme:", total);
  output += line("Rundungsdifferenz:", roundingDiff);
  output += line("Netto:", netto);
  output += line("MwSt (19%):", mwst);
  output += ("Gesamtanzahl Kunden:".padEnd(labelWidth) + String(totalCustomers).padStart(10) + "\n");

    output += ("Gesamtanzahl Arbeitstage:".padEnd(labelWidth) + String(totalWorkdays).padStart(10) + "\n");
const rp = document.getElementById("reduced-print");
  if (rp) {
    setReducedPrintHtmlFromText(output);
    rp.style.display = "block";
    setTimeout(() => {
      window.print();
      rp.style.display = "none";
    }, 100);
  }
}





// Offline-Excel-Export (XLSX) ohne externe Bibliotheken
// Erzeugt eine minimale .xlsx-Datei (ZIP + Office Open XML) direkt im Browser.
// Unterst√ºtzt Text und Zahlen (Zahlen werden automatisch erkannt, auch mit deutschem Komma).
(function(){
  function _xlsxEscapeXml(s){
    return String(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }

  function _xlsxSanitizeSheetName(name){
    let n = String(name || "Tabelle1");
    // Excel: max 31 chars, no : \/ ? * [ ]
    n = n.replace(/[\\\/:\?\*\[\]]/g, " ").trim();
    if (!n) n = "Tabelle1";
    if (n.length > 31) n = n.slice(0, 31);
    return n;
  }

  function _colName(idx){
    // 0 -> A, 25 -> Z, 26 -> AA
    let n = idx + 1;
    let s = "";
    while (n > 0){
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function _cellRef(c, r){
    return _colName(c) + String(r + 1);
  }

  function _inferCell(v){
    if (v === null || v === undefined) return { type: "empty", value: "" };

    // Handle custom value objects for Excel export. When v is an object with a
    // 'v' property, treat that property as the actual cell content and honour
    // an optional 'isDecimal' flag for number formatting. This allows
    // exportExcel/exportQuarterExcel to mark monetary values for a number
    // format with two decimal places while keeping count values unformatted.
    if (v && typeof v === 'object' && Object.prototype.hasOwnProperty.call(v, 'v')) {
      const cellVal = v.v;
      const decimal = !!v.isDecimal;
      if (cellVal === null || cellVal === undefined) {
        return { type: "empty", value: "" };
      }
      if (typeof cellVal === 'number' && isFinite(cellVal)) {
        // Return numeric cell and propagate decimal flag so that _buildSheetXml can apply a style.
        return { type: "n", value: String(cellVal), decimal: decimal };
      }
      // Fallback: treat as plain string
      const sObj = String(cellVal).trim();
      if (!sObj) return { type: "empty", value: "" };
      const maybeFormulaObj = /^[=+\-@]/.test(sObj);
      return { type: "s", value: maybeFormulaObj ? ("'" + sObj) : sObj };
    }

    if (typeof v === "number" && isFinite(v)) {
      return { type: "n", value: String(v) };
    }

    // Strings: try parse numbers (also German comma)
    const s = String(v).trim();
    if (!s) return { type: "empty", value: "" };

    // Prevent formula injection: prefix with apostrophe if it starts with Excel formula chars
    const maybeFormula = /^[=+\-@]/.test(s);

    const numLike = /^-?(\d+)([\.,]\d+)?$/.test(s);
    if (numLike) {
      // Versuche, Komma als Dezimaltrennzeichen zu interpretieren und gib einen numerischen Zelltyp zur√ºck.
      const n = parseFloat(s.replace(',', '.'));
      if (isFinite(n)) return { type: "n", value: String(n) };
    }

    return { type: "s", value: maybeFormula ? ("'" + s) : s };
  }

  function _buildSheetXml(aoa){
    const rows = Array.isArray(aoa) ? aoa : [];
    let out = '';
    out += '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
    out += '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">';
    out += '<sheetData>';

    for (let r = 0; r < rows.length; r++){
      const row = Array.isArray(rows[r]) ? rows[r] : [rows[r]];
      out += `<row r="${r+1}">`;

      for (let c = 0; c < row.length; c++){
        const cell = _inferCell(row[c]);
        if (cell.type === 'empty') continue;
        const ref = _cellRef(c, r);

        if (cell.type === 'n') {
          // Apply a number format style when cell.decimal is true. Style index 1
          // corresponds to the built‚Äëin number format 0.00 (two decimal places)
          // declared in styles.xml. Without decimal flag, omit the style
          // attribute so Excel will use the general format.
          if (cell.decimal) {
            out += `<c r="${ref}" s="1"><v>${_xlsxEscapeXml(cell.value)}</v></c>`;
          } else {
            out += `<c r="${ref}"><v>${_xlsxEscapeXml(cell.value)}</v></c>`;
          }
        } else {
          out += `<c r="${ref}" t="inlineStr"><is><t>${_xlsxEscapeXml(cell.value)}</t></is></c>`;
        }
      }

      out += '</row>';
    }

    out += '</sheetData>';
    out += '</worksheet>';
    return out;
  }

  function _u8(str){
    return new TextEncoder().encode(str);
  }

  // CRC32
  const _crcTable = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i++){
      let c = i;
      for (let k = 0; k < 8; k++){
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function _crc32(u8){
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < u8.length; i++){
      crc = _crcTable[(crc ^ u8[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
  }

  function _concatU8(chunks){
    let total = 0;
    for (const c of chunks) total += c.length;
    const out = new Uint8Array(total);
    let off = 0;
    for (const c of chunks){
      out.set(c, off);
      off += c.length;
    }
    return out;
  }

  function _makeLocalHeader(nameBytes, crc, size){
    const header = new Uint8Array(30 + nameBytes.length);
    const dv = new DataView(header.buffer);
    dv.setUint32(0, 0x04034b50, true);
    dv.setUint16(4, 20, true);
    dv.setUint16(6, 0, true);
    dv.setUint16(8, 0, true);
    dv.setUint16(10, 0, true);
    dv.setUint16(12, 0, true);
    dv.setUint32(14, crc, true);
    dv.setUint32(18, size, true);
    dv.setUint32(22, size, true);
    dv.setUint16(26, nameBytes.length, true);
    dv.setUint16(28, 0, true);
    header.set(nameBytes, 30);
    return header;
  }

  function _makeCentralHeader(nameBytes, crc, size, offset){
    const header = new Uint8Array(46 + nameBytes.length);
    const dv = new DataView(header.buffer);
    dv.setUint32(0, 0x02014b50, true);
    dv.setUint16(4, 20, true); // version made by
    dv.setUint16(6, 20, true); // version needed
    dv.setUint16(8, 0, true);
    dv.setUint16(10, 0, true);
    dv.setUint16(12, 0, true);
    dv.setUint16(14, 0, true);
    dv.setUint32(16, crc, true);
    dv.setUint32(20, size, true);
    dv.setUint32(24, size, true);
    dv.setUint16(28, nameBytes.length, true);
    dv.setUint16(30, 0, true);
    dv.setUint16(32, 0, true);
    dv.setUint16(34, 0, true);
    dv.setUint16(36, 0, true);
    dv.setUint32(38, 0, true);
    dv.setUint32(42, offset, true);
    header.set(nameBytes, 46);
    return header;
  }

  function _makeEndCentralDir(numEntries, centralSize, centralOffset){
    const eocd = new Uint8Array(22);
    const dv = new DataView(eocd.buffer);
    dv.setUint32(0, 0x06054b50, true);
    dv.setUint16(4, 0, true);
    dv.setUint16(6, 0, true);
    dv.setUint16(8, numEntries, true);
    dv.setUint16(10, numEntries, true);
    dv.setUint32(12, centralSize, true);
    dv.setUint32(16, centralOffset, true);
    dv.setUint16(20, 0, true);
    return eocd;
  }

  function _zipStore(files){
    const localParts = [];
    const centralParts = [];
    let offset = 0;

    for (const f of files){
      const nameBytes = _u8(f.name);
      const data = f.data;
      const size = data.length;
      const crc = _crc32(data);

      const localHeader = _makeLocalHeader(nameBytes, crc, size);
      localParts.push(localHeader, data);

      const centralHeader = _makeCentralHeader(nameBytes, crc, size, offset);
      centralParts.push(centralHeader);

      offset += localHeader.length + data.length;
    }

    const centralOffset = offset;
    const centralBlob = _concatU8(centralParts);
    const centralSize = centralBlob.length;
    const eocd = _makeEndCentralDir(files.length, centralSize, centralOffset);

    return _concatU8([_concatU8(localParts), centralBlob, eocd]);
  }

  function buildMinimalXlsxBinary(aoa, sheetName){
    const safeName = _xlsxSanitizeSheetName(sheetName || 'Tabelle1');

    const sheetXml = _buildSheetXml(aoa);
    // Workbook XML describing the sheet. The workbook itself does not need to
    // reference styles directly; relationships (relsWb) will handle that.
    const workbookXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">` +
      `<sheets><sheet name="${_xlsxEscapeXml(safeName)}" sheetId="1" r:id="rId1"/></sheets>` +
      `</workbook>`;

    // Root relationships: the workbook is the only target from the package root.
    const relsRoot = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>` +
      `</Relationships>`;

    // Workbook relationships: define connections to the sheet and style parts.
    const relsWb = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">` +
      `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>` +
      `<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>` +
      `</Relationships>`;

    // Styles XML: include a minimal stylesheet defining a number format with
    // two decimal places. Style index 0 is the default (general) and index 1
    // applies built‚Äëin format ID 4 (which corresponds to "#\,##0.00").
    const stylesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">` +
      `<fonts count="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>` +
      `<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>` +
      `<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>` +
      `<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>` +
      `<cellXfs count="2">` +
        `<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>` +
        `<xf numFmtId="4" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>` +
      `</cellXfs>` +
      `</styleSheet>`;

    // Content types: define overrides for the workbook, worksheet and styles parts.
    const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
      `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">` +
      `<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>` +
      `<Default Extension="xml" ContentType="application/xml"/>` +
      `<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>` +
      `<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>` +
      `<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>` +
      `</Types>`;

    // Assemble all files required for the minimal XLSX package. The order here
    // does not matter for ZIP packaging, but relationships must match the
    // definitions above.
    const files = [
      { name: '[Content_Types].xml', data: _u8(contentTypes) },
      { name: '_rels/.rels', data: _u8(relsRoot) },
      { name: 'xl/workbook.xml', data: _u8(workbookXml) },
      { name: 'xl/_rels/workbook.xml.rels', data: _u8(relsWb) },
      { name: 'xl/worksheets/sheet1.xml', data: _u8(sheetXml) },
      { name: 'xl/styles.xml', data: _u8(stylesXml) },
    ];

    return _zipStore(files);
  }

  async function saveAoAToXlsxFile(aoa, sheetName, defaultName){
    const filename = (defaultName && String(defaultName).trim()) ? String(defaultName).trim() : 'export.xlsx';
    const ensureXlsx = (n) => n.toLowerCase().endsWith('.xlsx') ? n : (n + '.xlsx');
    const finalName = ensureXlsx(filename);

    const data = buildMinimalXlsxBinary(aoa, sheetName || 'Tabelle1'); // Uint8Array

    // 1) Desktop (Electron)
    try {
      if (window.electronAPI && typeof window.electronAPI.saveBinaryFile === 'function') {
        const result = await window.electronAPI.saveBinaryFile({
          title: 'Excel speichern',
          defaultName: finalName,
          filters: [{ name: 'Excel-Datei', extensions: ['xlsx'] }],
          data
        });
        return !!(result && !result.canceled);
      }
    } catch (e) {
      console.warn('Excel-Speichern (Desktop) fehlgeschlagen ‚Äì Fallback auf Browser-Download.', e);
    }

    // 2) Browser Download
    try {
      const blob = new Blob([data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = finalName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      return true;
    } catch (e) {
      console.error('Excel-Export fehlgeschlagen:', e);
      try { alert('Excel-Export fehlgeschlagen: ' + (e && e.message ? e.message : e)); } catch(_) {}
      return false;
    }
  }

  // Exportfunktion global verf√ºgbar machen
  window.saveAoAToXlsxFile = saveAoAToXlsxFile;
})();


async function exportQuarterExcel() {
  const q = getSelectedQuarter();
  const months = getQuarterMonths(q);
  const year = selYear;
  const ws_data = [];
  // Titelzeile + Leerzeile (f√ºr den Excel-Ausdruck / Archiv)
  ws_data.push([`Einnahmen Quartal Q${q} ${year}`]);
  ws_data.push([]);
  let grandTotal = 0;
  let grandCustomers = 0;
  let grandWorkdays = 0;

  months.forEach(m => {
    const days = daysInMonth(year, m);
    let monthTotal = 0;
    let monthCustomers = 0;
    let monthWorkdays = 0;
    ws_data.push([]);
    ws_data.push([monthNames[m] + " " + year]);

    for (let d = 1; d <= days; d++) {
      const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      const freeKey = "cf-" + year + "-" + m + "-" + d;
      const freeType = localStorage.getItem(freeKey);

      const hasEntries = rows && rows.some(r => {
        const a1 = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
        const a2 = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
        const tip = r.amountTip !== undefined ? r.amountTip : "";
        return (a1 && parseFloat(String(a1).replace(",", ".")) > 0) ||
               (a2 && parseFloat(String(a2).replace(",", ".")) > 0) ||
               (tip && parseFloat(String(tip).replace(",", ".")) > 0);
      });

      if (freeType) {
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank" ? "Krankheitstag" : "Eigener freier Tag");
        ws_data.push([dateStr, label]);
        ws_data.push([]);
        continue;
      }

      let tagSum = 0;
      let kunden = 0;
      const dayLines = [];

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));
          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);

          if (sumVal > 0) {
            kunden++;
            const fmt = n => n.toFixed(2).replace(".", ",");
            // F√ºr jede Buchungszeile unterscheiden wir zwischen numerischer Darstellung (f√ºr Summen) und Textdarstellung
            // (f√ºr die kombinierten Teile). fmtNum liefert eine Zahl mit zwei Dezimalstellen, fmtStr liefert einen
            // formatierten String mit deutschem Dezimaltrennzeichen f√ºr Texte.
            const fmtStr = n => n.toFixed(2).replace(".", ",");
            // Wrap numeric values for Excel export: returns an object marking
            // monetary values for two‚Äëdecimal formatting. See _inferCell.
            const fmtNum = n => ({ v: Number(n.toFixed(2)), isDecimal: true });
            const formattedSumObj = fmtNum(sumVal);
            const fmt1 = !isNaN(num1) ? fmtStr(num1) : "";
            const fmt2 = !isNaN(num2) && num2 > 0 ? fmtStr(num2) : "";
            const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmtStr(numTip) : "";

            let parts = [];
            if (fmt1) parts.push(fmt1);
            if (fmt2) parts.push(fmt2);
            if (fmtTip) parts.push(fmtTip);

            if (parts.length > 1) {
              dayLines.push(["", formattedSumObj, parts.join(" + ")]);
            } else {
              dayLines.push(["", formattedSumObj, ""]);
            }
            tagSum += sumVal;
          }
        });
      }

      if (tagSum > 0) {
  const kundenLabel = (kunden === 1 ? "Kunde" : "Kunden");
  const isSingleCustomer = (kunden === 1 && dayLines.length === 1);

  if (isSingleCustomer) {
    const details = String(dayLines[0][2] || "").trim();
    const kundenCell = `|   ${kunden} ${kundenLabel}` + (details ? `   ${details}` : "");
    ws_data.push([dateStr, dayLines[0][1], kundenCell]);
    ws_data.push([]);
  } else {
    dayLines.forEach((l, index) => {
      if (index === 0) {
        ws_data.push([dateStr, l[1], l[2]]);
  }
else {
        ws_data.push(["", l[1], l[2]]);
      }
    });

    ws_data.push(["", "----------"]);
    // Tagessumme als Zahl speichern (nicht als Text), um Excel-Warnung zu vermeiden
    // Tagessumme als Objekt mit Dezimalformat markieren
    ws_data.push(["", { v: Number(tagSum.toFixed(2)), isDecimal: true }, `|   ${kunden} ${kundenLabel}`]);
    ws_data.push([]);
  }

  monthTotal += tagSum;
  monthCustomers += kunden;
  monthWorkdays += 1;
}
    }

    if (monthTotal > 0) {
      // F√ºr Monats√ºbersicht im Quartal: Zahlen mit zwei Dezimalstellen als numerische Werte zur√ºckgeben
      const fmt = n => {
        const rounded = Number(n.toFixed(2));
        return { v: rounded, isDecimal: true };
      };
      const netto = monthTotal / 1.19;
      const mwst = monthTotal - netto;
      ws_data.push([]);
      ws_data.push(["Monats√ºbersicht " + monthNames[m] + " " + year]);
      ws_data.push(["Gesamtsumme", fmt(monthTotal)]);
      ws_data.push(["Netto", fmt(netto)]);
      ws_data.push(["MwSt", fmt(mwst)]);
      // Die Gesamtzahlen sollen in Spalte C erscheinen. Wir f√ºgen eine leere
      // Spalte ein und platzieren die Werte in Spalte C.
      // Gesamtzahlen in Spalte C anstatt D
      ws_data.push(["Gesamtanzahl Kunden", "", monthCustomers]);
      ws_data.push(["Gesamtanzahl Arbeitstage", "", monthWorkdays]);
      ws_data.push([]);
    }

    grandTotal += monthTotal;
    grandCustomers += monthCustomers;
    grandWorkdays += monthWorkdays;
  });

  if (grandTotal > 0) {
    // F√ºr die Quartals√ºbersicht: Zahlen mit zwei Dezimalstellen als numerische Werte zur√ºckgeben
    const fmt = n => {
      const rounded = Number(n.toFixed(2));
      return { v: rounded, isDecimal: true };
    };
    const netto = grandTotal / 1.19;
    const mwst = grandTotal - netto;
    ws_data.push([]);
    ws_data.push([`Quartals√ºbersicht Q${q} ${year}`]);
    ws_data.push(["Gesamtsumme", fmt(grandTotal)]);
    ws_data.push(["Netto", fmt(netto)]);
    ws_data.push(["MwSt", fmt(mwst)]);
    // Gesamtzahlen des Quartals ebenfalls in Spalte C ausgeben
    // Gesamtzahlen des Quartals in Spalte C anstatt D
    ws_data.push(["Gesamtanzahl Kunden", "", grandCustomers]);
    ws_data.push(["Gesamtanzahl Arbeitstage", "", grandWorkdays]);
}
  const defaultName = `einnahmen_quartal_Q${q}_${year}.xlsx`;
  await saveAoAToXlsxFile(ws_data, 'Quartal', defaultName);
}
function generateReducedPrint() {
  let output = "";
  const month = document.getElementById("selected-month").innerText;
  output += "Einnahmen " + month + "\n\n";

  let total = 0;
  let totalCustomers = 0;
  let totalWorkdays = 0;
  let printedTotal = 0;

  // Einheitliche Breite f√ºr Datumsspalten: Damit die Betr√§ge der Tageszeilen
  // und die Betr√§ge in der Monats√ºbersicht (labelWidth) auf der gleichen
  // Spalte beginnen, verwenden wir eine deutlich gr√∂√üere Breite f√ºr die
  // Datumsangaben. Urspr√ºnglich wurden die Datumsangaben nur auf eine
  // Breite von 12 Zeichen aufgef√ºllt; dies f√ºhrte dazu, dass die
  // Monatssummen weiter rechts standen. Mit datePadWidth passen wir die
  // Breite an labelWidth (26) an, sodass die Werte untereinander stehen.
  const datePadWidth = 26;

  // Lokale Formatierungsfunktion: Formatiert eine Zahl mit zwei Dezimalstellen
  // und verwendet ein Komma als Dezimaltrennzeichen. Diese Funktion wird
  // ausschlie√ülich f√ºr den reduzierten Druck verwendet und kollidiert nicht
  // mit anderen fmt-Definitionen in exportExcel/exportQuarterExcel.
  const fmt = (n) => {
    if (typeof n !== 'number' || isNaN(n)) return "";
    return n.toFixed(2).replace(".", ",");
  };

  for (let d = 1; d <= selDays; d++) {
    const tbody = document.getElementById("day-" + d);
    if (!tbody) continue;

    const rows = tbody.querySelectorAll("tr.entry-row");
    // Falls es keine Eintragszeilen gibt, pr√ºfen ob der Tag als Urlaub oder Krankheit markiert ist.
    if (rows.length === 0) {
      // Typ des eigenen freien Tages aus dem localStorage abrufen, sofern Funktion verf√ºgbar.
      let freeType = null;
      try {
        if (typeof getFreeDayType === 'function') {
          freeType = getFreeDayType(d);
        }
      } catch (e) {
        freeType = null;
      }
      // Wenn der Tag als frei markiert ist, Grund in den Ausdruck aufnehmen.
      if (freeType) {
        // Datum im Format TT.MM.JJJJ
        const date = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
        // Menschlich lesbare Beschriftung abh√§ngig vom Typ
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank"
             ? "Krankheitstag"
             : "Eigener freier Tag");
        output += date.padEnd(datePadWidth) + label + "\n\n";
      }
      continue;
    }

    let tagSum = 0;
    let kunden = 0;
    let zeilen = [];
    let zeilenDetails = [];

    rows.forEach(r => {
      // Betragswerte als Strings auslesen und in Zahlen konvertieren
      const a1Str = r.querySelector(".amount1")?.value || "";
      const a2Str = r.querySelector(".amount2")?.value || "";
      const tipStr = r.querySelector(".amountTip")?.value || "";
      const num1 = parseFloat(String(a1Str).replace(",", "."));
      const num2 = parseFloat(String(a2Str).replace(",", "."));
      const numTip = parseFloat(String(tipStr).replace(",", "."));
      const sumVal = (isNaN(num1) ? 0 : num1) + (isNaN(num2) ? 0 : num2) + (isNaN(numTip) ? 0 : numTip);
      if (sumVal > 0) {
        kunden++;
        // Formatierfunktion f√ºr zwei Dezimalstellen mit deutschem Dezimaltrennzeichen
        // Entfernt: urspr√ºngliche String-Formatierungsfunktion f√ºr Zahlen (nicht mehr ben√∂tigt)
        const formattedSum = fmt(sumVal);
        // formatierte Einzelbetr√§ge
        const fmt1 = !isNaN(num1) ? fmt(num1) : "";
        const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
        const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";
        let line;
        let parts = [];
        if (fmt1) parts.push(fmt1);
        if (fmt2) parts.push(fmt2);
        if (fmtTip) parts.push(fmtTip);
        if (parts.length > 1) {
          line = formattedSum.padStart(10) + "   " + parts.join(" + ");
        } else {
          line = formattedSum.padStart(10);
        }
        zeilen.push(line);
        zeilenDetails.push(parts.length > 1 ? parts.join(" + ") : "");
        tagSum += sumVal;
      }
    });

    if (tagSum > 0) {
      // Datum im Format TT.MM.JJJJ
      const date = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
const kundenLabel = (kunden === 1 ? "Kunde" : "Kunden");

if (kunden === 1) {
  const detailAfter = (zeilenDetails[0] ? "   " + zeilenDetails[0] : "");
  output += date.padEnd(datePadWidth)
    + tagSum.toFixed(2).replace(".", ",").padStart(10)
    + "   |   1 " + kundenLabel
    + detailAfter
    + "\n\n";
} else {

  const maxLines = Math.max(zeilen.length, 1);
  for (let i = 0; i < maxLines; i++) {
    const datum = i === 0 ? date.padEnd(datePadWidth) : " ".repeat(datePadWidth);
    const einnahme = zeilen[i] || "";
    output += datum + einnahme + "\n";
  }
  output += " ".repeat(datePadWidth) + "----------\n";
  output += " ".repeat(datePadWidth)
    + tagSum.toFixed(2).replace(".", ",").padStart(10)
    + "   |   " + kunden + " " + kundenLabel + "\n\n";
}

      const roundedDay = Math.round(tagSum * 100) / 100;
      printedTotal += roundedDay;
      total += tagSum;
      totalCustomers += kunden;
      totalWorkdays += 1;
      }
  }

  // Netto und MwSt aus der Gesamtsumme (inkl. Trinkgeld) berechnen
  const netto = total / 1.19;
  const mwst = total - netto;

    const roundedTotal = Math.round(printedTotal * 100) / 100;
  const roundingDiff = Math.round((roundedTotal - total) * 100) / 100;

const labelWidth = 26;
  // Helferfunktion f√ºr eine Zeile der Monats√ºbersicht
  function line(label, value) {
    return label.padEnd(labelWidth) + value.toFixed(2).replace(".", ",").padStart(10) + "\n\n";
  }

  // Monats√ºbersicht (FA-optimiert mit Rundungsdifferenz)
  output += "Monats√ºbersicht\n";
  output += "----------------\n\n";
  output += line("Summe Tagessummen:", roundedTotal);
  output += line("Exakte Gesamtsumme:", total);
  output += line("Rundungsdifferenz:", roundingDiff);
  output += line("Netto:", netto);
  output += line("MwSt (19%):", mwst);
  // Gesamtanzahl der Kunden anh√§ngen
  output += "Gesamtanzahl Kunden:".padEnd(labelWidth) + String(totalCustomers).padStart(10) + "\n\n";
  output += "Gesamtanzahl Arbeitstage:".padEnd(labelWidth) + String(totalWorkdays).padStart(10) + "\n\n";

  // Text in das versteckte Druckdiv schreiben und anzeigen
  const rp = document.getElementById("reduced-print");
  setReducedPrintHtmlFromText(output);
  rp.style.display = "block";
  // kurze Verz√∂gerung, damit das DOM aktualisiert wird
  setTimeout(() => {
    window.print();
    rp.style.display = "none";
  }, 100);
}
</script>
<script>
function updateCustomerTotal() {
  let totalCustomers = 0;
  const workdays = new Set();

  const rows = document.querySelectorAll("tbody[id^='day-'] tr.entry-row");
  rows.forEach(row => {
    const amount1 = row.querySelector(".amount1")?.value || "";
    const amount2 = row.querySelector(".amount2")?.value || "";
    const tipVal = row.querySelector(".amountTip")?.value || "";
    let sum = 0;
    if (amount1) sum += parseFloat(amount1.replace(",", "."));
    if (amount2) sum += parseFloat(amount2.replace(",", "."));
    if (tipVal) sum += parseFloat(tipVal.replace(",", "."));

    if (sum > 0) {
      totalCustomers++;
      const day = getDayFromEntryRow(row);
      if (day != null) workdays.add(day);
    }
  });

  const target = document.getElementById("grand-customers");
  if (target) target.textContent = totalCustomers;

  const wdTarget = document.getElementById("grand-workdays");
  if (wdTarget) wdTarget.textContent = String(workdays.size);
}

document.addEventListener("DOMContentLoaded", updateCustomerTotal);
document.addEventListener("input", function(e) {
  if (e.target.classList.contains("amount1") ||
      e.target.classList.contains("amount2") ||
      e.target.classList.contains("amountTip")) {

    updateCustomerTotal();

    const row = e.target.closest("tr.entry-row");
    const day = getDayFromEntryRow(row);
    if (day !== null) {
      updateDay(day);
    }
  }
});


// Delegate click events for scroll-to-summary elements to smoothly scroll to the monthly totals
document.addEventListener('click', function(event) {
  const circle = event.target.closest('.scroll-circle');
  if (circle && circle.closest('.scroll-to-summary')) {
    // Nur ein Klick direkt auf den Kreis-Pfeil in der Tageszeile
    // scrollt zur Monats√ºbersicht.
    event.preventDefault();
    const totals = document.getElementById('onscreen-totals');
    if (totals) {
      totals.scrollIntoView({ behavior: 'smooth' });
    }
  }
});


document.addEventListener('click', function(event) {
  // Nur ein Klick direkt auf den Kreis-Pfeil im unteren "Zur√ºck"-Bereich
  // soll scrollBackToLastEntry ausl√∂sen, nicht ein Klick daneben.
  const backCircle = event.target.closest('.scroll-back-wrapper .scroll-circle');
  if (backCircle) {
    event.preventDefault();
    scrollBackToLastEntry();
  }
});

// Keep track of which entry row currently holds the scroll indicator

// Hilfsfunktion: Liefert die Tagesnummer (1..31) f√ºr eine Eintragszeile
// oder null, falls die Zeile keinem Tag zugeordnet werden kann.
function getDayFromEntryRow(row) {
  if (!row) return null;
  const tbody = row.closest("tbody[id^='day-']");
  if (!tbody || !tbody.id) return null;
  const parts = tbody.id.split("-");
  if (parts.length < 2) return null;
  const day = parseInt(parts[1], 10);
  return isNaN(day) ? null : day;
}

// Entfernt die letzte Eintragszeile eines Tages, falls sie komplett leer ist
// (weder Betrag 1 noch Betrag 2) und es noch mindestens eine weitere Zeile
// in diesem Tag gibt. Dadurch verschwinden unbenutzte, per Enter erzeugte
// Zusatzzeilen automatisch, sobald im n√§chsten Tag weitergearbeitet wird.
function removeTrailingEmptyRow(day) {
  if (day == null) return;
  const tbody = document.getElementById("day-" + day);
  if (!tbody) return;

  let rows = tbody.querySelectorAll("tr.entry-row");
  let removed = false;

  // Alle leeren Zeilen am Ende eines Tages entfernen, aber immer
  // mindestens eine Zeile pro Tag √ºbrig lassen.
  while (rows.length > 1) {
    const lastRow = rows[rows.length - 1];
    const a1 = lastRow.querySelector(".amount1");
    const a2 = lastRow.querySelector(".amount2");
    const hasValue = (a1 && a1.value !== "") || (a2 && a2.value !== "");
    if (hasValue) break;
    lastRow.remove();
    removed = true;
    rows = tbody.querySelectorAll("tr.entry-row");
  }

  if (removed) {
    updateDay(day);
  }
}



/**
 * Setzt einen Standardbetrag (z.B. 33 ‚Ç¨) in das Betrag-1-Feld der aktuellen Zeile.
 * Der Button steht links neben dem Feld und bezieht den passenden Tag √ºber den Parameter day.
 */
function setStandardAmountForRow(button, value, day) {
  const wrapper = button.closest('.amount1-wrapper');
  if (!wrapper) return;
  const input = wrapper.querySelector('.amount1');
  if (!input) return;

  input.value = value;

  if (typeof checkInput === "function") {
    checkInput(input);
  }

  if (typeof updateDay === "function" && !isNaN(day)) {
    updateDay(day);
  }

  input.focus();
  if (typeof input.select === "function") {
    input.select();
  }
}

let lastFocusedDay = null;

let currentScrollRow = null;

/**
 * Move the arrow indicator to the given entry row. The indicator is shown by
 * inserting a downward arrow character into the row's scroll-to-summary cell and
 * clearing it from any previous row. This ensures only one arrow is visible at
 * a time.
 * @param {HTMLElement} row The table row (tr.entry-row) to highlight.
 */
function updateScrollArrow(row) {
  // Remove arrow from previous row but keep the sum text
  if (currentScrollRow && currentScrollRow !== row) {
    const prevCell = currentScrollRow.querySelector('.scroll-to-summary');
    if (prevCell) {
      // If a sum-value span exists, restore its text as the only content
      const sumSpan = prevCell.querySelector('.sum-value');
      if (sumSpan) {
        prevCell.textContent = sumSpan.textContent;
      } else {
        // Otherwise just clear any arrow markup
        prevCell.textContent = prevCell.textContent;
      }
      prevCell.classList.remove('active');
      prevCell.removeAttribute('title');
    }
  }
  currentScrollRow = row;
  // Set arrow on the current row, preserving the existing sum value
  if (row) {
    const cell = row.querySelector('.scroll-to-summary');
    if (cell) {
      // Capture current sum text; if an existing sum-value span exists, use its content, otherwise use the cell text
      let currentSumText;
      const existingSumSpan = cell.querySelector('.sum-value');
      if (existingSumSpan) {
        currentSumText = existingSumSpan.textContent;
      } else {
        currentSumText = cell.textContent;
      }
      cell.innerHTML = `<span class="sum-value">${currentSumText}</span>` +
                       `<span class="scroll-circle">‚Üì</span>` +
                       `<span class="scroll-text"> zur Monats√ºbersicht</span>`;
      cell.classList.add('active');
      cell.setAttribute('title', 'Zur Monats√ºbersicht scrollen');
    }
  }
}

// When an amount field gains focus, move the arrow to its row
document.addEventListener('focusin', function(e) {
  if (e.target && (e.target.classList.contains('amount1') || e.target.classList.contains('amount2'))) {
    const row = e.target.closest('tr.entry-row');
    if (row) {
      const day = getDayFromEntryRow(row);
      // Wenn von einem Tag zu einem anderen gewechselt wird, ggf. letzte
      // leere Zusatzzeile im vorherigen Tag entfernen.
      if (lastFocusedDay !== null && day !== null && day !== lastFocusedDay) {
        removeTrailingEmptyRow(lastFocusedDay);
      }
      lastFocusedDay = day;
      updateScrollArrow(row);
    }
  }
});

// Scroll to the monthly summary when the user clicks the scroll button
function scrollToTotals() {
  const totals = document.getElementById("onscreen-totals");
  if (totals) {
    totals.scrollIntoView({ behavior: "smooth" });
  }
}

// Scrollt zur zuletzt bearbeiteten Eintragszeile (falls vorhanden)
function scrollBackToLastEntry() {
  // Wenn keine Daten vorhanden sind, ganz nach oben zum Seitenanfang scrollen.
  if (!hasAnyDataInMonth()) {
    window.scrollTo({ top: 0, behavior: 'smooth' });
    return;
  }
  // Finde den letzten Tag (h√∂chste Tagesnummer) mit einem Eintrag
  let lastDayWithData = null;
  for (let d = selDays; d >= 1; d--) {
    if (dayHasAnyEntry(d)) {
      lastDayWithData = d;
      break;
    }
  }
  if (lastDayWithData != null) {
    const tbody = document.getElementById("day-" + lastDayWithData);
    if (tbody) {
      // W√§hle die erste Eintragszeile in diesem Tag
      const row = tbody.querySelector("tr.entry-row");
      if (row) {
        // Setze den Scroll-Indikator auf diese Zeile
        updateScrollArrow(row);
        // Scrolle zur Zeile, zentriert im viewport
        const rect = row.getBoundingClientRect();
        const rowTop = rect.top + window.pageYOffset;
        let target = rowTop - (window.innerHeight / 2) + (rect.height / 2);
        if (target < 0) target = 0;
        window.scrollTo({ top: target, behavior: 'smooth' });
        return;
      }
    }
  }
  // Fallback: wenn currentScrollRow gesetzt ist, dorthin scrollen
  if (currentScrollRow) {
    const rect = currentScrollRow.getBoundingClientRect();
    const rowTop = rect.top + window.pageYOffset;
    let target = rowTop - (window.innerHeight / 2) + (rect.height / 2);
    if (target < 0) target = 0;
    window.scrollTo({ top: target, behavior: 'smooth' });
  }
}
</script>
<script>
async function exportExcel() {
  const ws_data = [];

  // Titelzeile + Leerzeile (f√ºr den Excel-Ausdruck / Archiv)
  (function addExcelTitleRow(){
    const monthLabel = (document.getElementById('selected-month') && document.getElementById('selected-month').innerText)
      ? document.getElementById('selected-month').innerText
      : ((typeof monthNames !== 'undefined' && monthNames[selMonth]) ? (monthNames[selMonth] + ' ' + selYear) : (String(selMonth+1).padStart(2,'0') + '.' + selYear));
    ws_data.push([`Einnahmen ${monthLabel}`]);
    ws_data.push([]);
  })();

  let total = 0;
  let totalCustomers = 0;
  let totalWorkdays = 0;

  for (let d = 1; d <= selDays; d++) {
    const dateStr = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
    const tbody = document.getElementById("day-" + d);
    if (!tbody) continue;

    const rows = tbody.querySelectorAll("tr.entry-row");

    // Eigene freie Tage (Urlaub / Krankheit / sonstiger freier Tag) ohne Eintr√§ge
    // sollen ebenfalls im Excel erscheinen.
    if (rows.length === 0) {
      let freeType = null;
      try {
        if (typeof getFreeDayType === "function") {
          freeType = getFreeDayType(d);
        }
      } catch (e) {
        freeType = null;
      }

      if (freeType) {
        let label;
        if (freeType === "urlaub") {
          label = "Urlaubstag";
        } else if (freeType === "krank") {
          label = "Krankheitstag";
        } else {
          // z.B. √§ltere Daten, bei denen nur ein generischer Wert gespeichert wurde
          label = "Eigener freier Tag";
        }

        ws_data.push([dateStr, label]);
        ws_data.push([]); // Leerzeile als Abstand
      }
      // Keine Ums√§tze/Kunden f√ºr freie Tage
      continue;
    }

    let dayLines = [];
    let tagSum = 0;
    let kunden = 0;

    rows.forEach(r => {
      const a1Str = r.querySelector(".amount1")?.value || "";
      const a2Str = r.querySelector(".amount2")?.value || "";
      const tipStr = r.querySelector(".amountTip")?.value || "";

      const num1 = parseFloat(String(a1Str).replace(",", "."));
      const num2 = parseFloat(String(a2Str).replace(",", "."));
      const numTip = parseFloat(String(tipStr).replace(",", "."));
      const sumVal =
        (isNaN(num1) ? 0 : num1) +
        (isNaN(num2) ? 0 : num2) +
        (isNaN(numTip) ? 0 : numTip);

      if (sumVal > 0) {
        kunden++;
        // Formatierungsfunktionen: fmtStr liefert einen formatierten String (deutsches Dezimaltrennzeichen) f√ºr Texte,
        // fmtNum liefert eine Zahl mit zwei Dezimalstellen f√ºr numerische Excel-Zellen.
        const fmtStr = n => n.toFixed(2).replace('.', ',');
        // For numeric Excel cells, wrap the value in an object with
        // isDecimal=true so the export logic knows to apply a two‚Äëdecimal
        // style. Without wrapping, numbers would use the default format and
        // drop trailing zeros.
        const fmtNum = n => ({ v: Number(n.toFixed(2)), isDecimal: true });
        const formattedSumObj = fmtNum(sumVal);
        const fmt1 = !isNaN(num1) ? fmtStr(num1) : "";
        const fmt2 = !isNaN(num2) && num2 > 0 ? fmtStr(num2) : "";
        const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmtStr(numTip) : "";

        let parts = [];
        if (fmt1) parts.push(fmt1);
        if (fmt2) parts.push(fmt2);
        if (fmtTip) parts.push(fmtTip);

        if (parts.length > 1) {
          dayLines.push(["", formattedSumObj, parts.join(" + ")]);
        } else {
          dayLines.push(["", formattedSumObj, ""]);
        }

        tagSum += sumVal;
      }
    });

    if (tagSum > 0) {
  const kundenLabel = (kunden === 1 ? "Kunde" : "Kunden");
  const isSingleCustomer = (kunden === 1 && dayLines.length === 1);

  if (isSingleCustomer) {
    const details = String(dayLines[0][2] || "").trim();
    const kundenCell = `|   ${kunden} ${kundenLabel}` + (details ? `   ${details}` : "");
    ws_data.push([dateStr, dayLines[0][1], kundenCell]);
    ws_data.push([]);
  } else {
    dayLines.forEach((l, index) => {
      if (index === 0) {
        ws_data.push([dateStr, l[1], l[2]]);
  }
else {
        ws_data.push(["", l[1], l[2]]);
      }
    });

    ws_data.push(["", "----------"]);
    // Tagessumme als Zahl speichern (nicht als Text)
    // Tagessumme als Objekt mit Dezimalformat markieren
    ws_data.push(["", { v: Number(tagSum.toFixed(2)), isDecimal: true }, `|   ${kunden} ${kundenLabel}`]);
    ws_data.push([]); // Leere Zeile
  }

  total += tagSum;
  totalCustomers += kunden;
  totalWorkdays += 1;
}
  }

  // Monats√ºbersicht mit Netto und MwSt (inkl. Trinkgeld)
  const netto = total / 1.19;
  const mwst = total - netto;

  // F√ºr den Excel-Export Zahlen mit zwei Dezimalstellen als numerische Werte zur√ºckgeben.
  // Der R√ºckgabewert ist ein Objekt mit dem numerischen Wert und dem Flag
  // isDecimal=true. So kann _inferCell/_buildSheetXml die Zelle mit dem
  // passenden Zahlenformat versehen.
  const fmt = n => {
    const rounded = Number(n.toFixed(2));
    return { v: rounded, isDecimal: true };
  };

  ws_data.push([]);
  ws_data.push(["Monats√ºbersicht"]);
  ws_data.push(["----------------"]);
  ws_data.push(["Gesamtsumme:", fmt(total)]);
  ws_data.push(["Netto:", fmt(netto)]);
  ws_data.push(["MwSt (19%):", fmt(mwst)]);
  // Die Gesamtzahlen sollen in Spalte C erscheinen. Wir f√ºgen daher
  // eine leere Spalte (B) ein und platzieren die Werte in Spalte C.
      // Verschiebe die Gesamtzahlen eine Spalte nach links (C statt D)
      ws_data.push(["Gesamtanzahl Kunden:", "", totalCustomers]);
      ws_data.push(["Gesamtanzahl Arbeitstage:", "", totalWorkdays]);
  const filename = `Einnahmen_${selYear}-${String(selMonth+1).padStart(2,"0")}.xlsx`;
  await saveAoAToXlsxFile(ws_data, 'Einnahmen', filename);
}

</script>
<script>
// Lock-Funktionen f√ºr Monatssperre
function isMonthLocked(year, month) {
  return localStorage.getItem(`locked-${year}-${month}`) === "1";
}

function setMonthLocked(year, month, locked) {
  if (locked) {
    localStorage.setItem(`locked-${year}-${month}`, "1");
  } else {
    localStorage.removeItem(`locked-${year}-${month}`);
  }
}

function toggleLock() {
  const locked = isMonthLocked(selYear, selMonth);
  setMonthLocked(selYear, selMonth, !locked);
  if (typeof requestAnimationFrame === 'function') {
    requestAnimationFrame(() => applyLockStatus());
  } else {
    setTimeout(() => applyLockStatus(), 0);
  }
}

function applyLockStatus() {
  const locked = isMonthLocked(selYear, selMonth);
  const lockIcon = document.getElementById("month-lock-toggle");
  if (lockIcon) {
    lockIcon.textContent = locked ? "üîí" : "üîì";
    lockIcon.title = locked
      ? "Monat ist gesperrt. Klick zum Entsperren."
      : "Monat ist offen. Klick zum Sperren.";
  }

  // In Electron kann nach Import/Loeschen gelegentlich ein 'disabled'-Zustand haengen bleiben.
  // Daher setzen wir IMMER explizit disabled=true/false und entfernen/setzen auch das Attribut.
  const controls = document.querySelectorAll("input, button, select, textarea");
  controls.forEach((el) => {
    try {
      if (!el) return;
      // Navigation/Schloss nicht sperren
      if (el.classList && el.classList.contains("nav-btn")) return;
      if (el.id === "month-lock-toggle") return;
      if (el.closest && el.closest("#month-nav")) return;

      el.disabled = !!locked;
      if (locked) el.setAttribute("disabled", "");
      else el.removeAttribute("disabled");
    } catch (_) {
      // Nichts: einzelne Sonderfaelle sollen die UI nicht blockieren
    }
  });
}

// In einigen Electron-Setups kann nach Import/Loeschen ein "interaktivitaets"-Zustand haengen bleiben
// (z.B. disabled-Attribute, readonly oder ein versehentlich gesetztes "inert").
// Diese Funktion setzt die UI brutal wieder in einen bearbeitbaren Zustand und wird danach
// durch applyLockStatus() wieder korrekt (nur bei echtem Monat-Lock) eingeschraenkt.
function forceEnableEditing() {
  try {
    // Druck-/Overlay-Container sicher ausblenden
    const rp = document.getElementById('reduced-print');
    if (rp) rp.style.display = 'none';

    // Inert entfernen (falls jemals gesetzt)
    document.querySelectorAll('[inert]').forEach(el => {
      try { el.removeAttribute('inert'); } catch(_) {}
    });

    // Pointer-Events wieder zulassen (falls durch irgendetwas auf none gesetzt)
    try { document.documentElement.style.pointerEvents = ''; } catch(_) {}
    try { document.body.style.pointerEvents = ''; } catch(_) {}

    // Alle Controls aktivieren
    const controls = document.querySelectorAll('input, select, textarea, button');
    controls.forEach(el => {
      try {
        if (!el) return;
        // Navigation/Schloss immer bedienbar lassen
        if (el.classList && el.classList.contains('nav-btn')) return;
        if (el.id === 'month-lock-toggle') return;
        if (el.closest && el.closest('#month-nav')) return;

        el.disabled = false;
        el.removeAttribute('disabled');
        if ('readOnly' in el) el.readOnly = false;
        el.removeAttribute('readonly');
      } catch(_) {}
    });

    // Fokus sanft zurueckholen (Electron verliert nach Dialogen gelegentlich den Fokus)
    try { window.focus(); } catch(_) {}
    setTimeout(() => {
      try {
        const first = document.querySelector('input.amount1');
        if (first) first.focus();
      } catch(_) {}
    }, 0);
  } catch (e) {
    // Niemals die App blockieren
    console.warn('forceEnableEditing failed:', e);
  }
}

// Nach nativen Dialogen (Datei-Auswahl / Alert / Confirm) verliert Electron
// gelegentlich den Fokus bzw. die Tastatureingabe landet nicht mehr in Inputs.
// Ein Klick ins Fenster behebt es ‚Äì wir machen das hier automatisiert.
function requestAppFocus() {
  try { window.focus(); } catch (_) {}
  try {
    if (window.electronAPI && typeof window.electronAPI.focusWindow === 'function') {
      window.electronAPI.focusWindow();
    }
  } catch (_) {}
}

function focusFirstEditableField() {
  try {
    // Erst das aktuell sichtbare/erste Betrag-1 Feld ansteuern
    const el = document.querySelector('input.amount1:not([disabled])') ||
               document.querySelector('input.amount1') ||
               document.querySelector('input, textarea, select');
    if (el) {
      el.focus({ preventScroll: true });
      if (typeof el.select === 'function') el.select();
    }
  } catch (_) {}
}

function refocusAfterNativeDialogs() {
  // Mehrere Versuche, weil Windows/Electron den Fokus manchmal zeitversetzt zurueckgibt
  const delays = [0, 60, 180, 450];
  delays.forEach(ms => {
    setTimeout(() => {
      requestAppFocus();
      // sicherstellen, dass Controls wirklich aktiv sind
      try { forceEnableEditing(); } catch (_) {}
      try { applyLockStatus(); } catch (_) {}
      focusFirstEditableField();
    }, ms);
  });
}

// Sperrstatus beim Monatswechsel anwenden
const _origUpdateMonth = updateMonth;
updateMonth = function () {
  try {
    _origUpdateMonth();
  } finally {
    // Defer, damit wirklich alle dynamischen Elemente im DOM sind
    if (typeof requestAnimationFrame === 'function') {
      requestAnimationFrame(() => {
        forceEnableEditing();
        applyLockStatus();
      });
    } else {
      setTimeout(() => {
        forceEnableEditing();
        applyLockStatus();
      }, 0);
    }
  }
};

// Sperrstatus beim JSON-Export ber√ºcksichtigen
const _origExportJSON = exportJSON;
exportJSON = function () {
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {},
    locked: isMonthLocked(selYear, selMonth) ? true : false
  };

  for(let d = 1; d <= selDays; d++){
    const key = "day-" + selYear + "-" + selMonth + "-" + d;
    const raw = localStorage.getItem(key);
    if(raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if(freeVal) data.free[cf] = freeVal;
  }

  const defaultName = "einnahmen_" + selYear + "-" + String(selMonth+1).padStart(2,"0") + ".json";
  // In einigen Offline-Umgebungen ist die prompt-Funktion deaktiviert.
  // Daher speichern wir ohne R√ºckfrage mit dem vorgeschlagenen Dateinamen.
  let filename = defaultName;
  if (!filename.toLowerCase().endsWith(".json")) {
    filename += ".json";
  }
const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};

// Sperrstatus beim Import wiederherstellen
const _origImportJSON = importJSON;
importJSON = function (ev) {
  const file = ev.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if(data.days){
        for(const key in data.days){
          localStorage.setItem(key, JSON.stringify(data.days[key]));
        }
      }
      if(data.free){
        for(const key in data.free){
          const val = data.free[key];
          if(val === 1 || val === "1" || val === true){
            localStorage.setItem(key, "urlaub");
          } else if(val === "urlaub" || val === "krank") {
            localStorage.setItem(key, val);
          } else {
            localStorage.setItem(key, "urlaub");
          }
        }
      }
      if(data.locked === true){
        localStorage.setItem(`locked-${data.year}-${data.month}`, "1");
      }
      /* Import ohne Reload: UI sofort aktualisieren */
      // Optional: nach Import auf den importierten Monat springen
      if (data && data.year != null && !Number.isNaN(Number(data.year))) selYear = Number(data.year);
      if (data && data.month != null && !Number.isNaN(Number(data.month))) selMonth = Number(data.month);

      // Sperrstatus: wenn im Import nicht vorhanden, Monat entsperren (stale locks vermeiden)
      const importedLocked = (data && Object.prototype.hasOwnProperty.call(data, "locked"))
        ? (data.locked === true || data.locked === 1 || data.locked === "1")
        : false;
      if (typeof setMonthLocked === "function") {
        setMonthLocked(selYear, selMonth, importedLocked);
      } else if (importedLocked) {
        localStorage.setItem(`locked-${selYear}-${selMonth}`, "1");
      } else {
        localStorage.removeItem(`locked-${selYear}-${selMonth}`);
      }

      try { hideMissingDayHint(); } catch(e) {}
      try { updateMonth(); } catch(e) { console.error(e); }
      try { applyLockStatus(); } catch(e) {}
      alert("Import erfolgreich.");
      try { ev.target.value = ""; } catch(e) {}
      try { if (typeof refocusAfterNativeDialogs === 'function') refocusAfterNativeDialogs(); } catch(e) {}
    } catch(err) {
      alert("Fehler beim Import: " + err.message);
    }
  };
  reader.readAsText(file);
};

// Schnelleingabe f√ºr einen Standardbetrag (z.B. 33 ‚Ç¨) in das aktuell ausgew√§hlte Betrag-1-Fel
function generateYearOverview() {
  const year = selYear;
  let output = "";
  let grandTotal = 0;
  let grandCustomers = 0;
  let grandWorkdays = 0;

  output += "Einnahmen Jahres√ºbersicht " + year + "\n\n";

  for (let m = 0; m < 12; m++) {
    const days = daysInMonth(year, m);
    let monthTotal = 0;
    let monthCustomers = 0;
    let monthWorkdays = 0;

    for (let d = 1; d <= days; d++) {
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      const freeKey = "cf-" + year + "-" + m + "-" + d;
      const freeType = localStorage.getItem(freeKey);
      if (freeType) {
        // Freier Tag √ºberschreibt evtl. alte gespeicherte Betr√§ge: nicht als Einnahme z√§hlen
        continue;
      }

      let daySum = 0;
      let dayCustomers = 0;

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));

          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);

          if (sumVal > 0) {
            daySum += sumVal;
            dayCustomers++;
          }
        });
      }

      // Ein Arbeitstag ist ein Tag, an dem mindestens 1 Kunde mit Betrag erfasst wurde.
      if (dayCustomers > 0) {
        monthTotal += daySum;
        monthCustomers += dayCustomers;
        monthWorkdays += 1;
      }
    }

    if (monthTotal > 0) {
      const fmt = n => n.toFixed(2).replace(".", ",");
      const netto = monthTotal / 1.19;
      const mwst = monthTotal - netto;
      const label = (monthNames[m] + " " + year).padEnd(18);

      output += label
        + "Brutto: " + fmt(monthTotal).padStart(10)
        + "   Netto: " + fmt(netto).padStart(10)
        + "   MwSt: " + fmt(mwst).padStart(10)
        + "   Kunden: " + String(monthCustomers).padStart(4)
        + "   AT: " + String(monthWorkdays).padStart(3)
        + "\n";

      grandTotal += monthTotal;
      grandCustomers += monthCustomers;
      grandWorkdays += monthWorkdays;
    }
  }

  if (grandTotal > 0) {
    const fmt = n => n.toFixed(2).replace(".", ",");
    const netto = grandTotal / 1.19;
    const mwst = grandTotal - netto;

    output += "\n";
    output += "Jahresgesamt " + year + "\n";
    output += "-------------------------\n";
    const labelWidth = 14; // muss mind. so breit sein wie "Arbeitstage:"
    output += "Brutto:".padEnd(labelWidth) + fmt(grandTotal).padStart(10) + "\n";
    output += "Netto:".padEnd(labelWidth) + fmt(netto).padStart(10) + "\n";
    output += "MwSt:".padEnd(labelWidth) + fmt(mwst).padStart(10) + "\n";
    output += "Kunden:".padEnd(labelWidth) + String(grandCustomers).padStart(10) + "\n";
    output += "Arbeitstage:".padEnd(labelWidth) + String(grandWorkdays).padStart(10) + "\n";
  } else {
    output += "F√ºr das Jahr " + year + " liegen keine Eintr√§ge vor.\n";
  }

  const rp = document.getElementById("reduced-print");
  if (rp) {
    if (typeof setReducedPrintHtmlFromText === "function") {
      setReducedPrintHtmlFromText(output);
    } else {
      rp.innerText = output;
    }
    rp.style.display = "block";
    setTimeout(() => {
      window.print();
      rp.style.display = "none";
    }, 100);
  }
}


</script>
<script>
(function(){
  function updateAdvancedControlsVisibility(){
    const input = document.getElementById('unlock-code');
    const adv = document.getElementById('advanced-controls');
    if(!input || !adv) return;
    const code = (input.value || '').trim();
    const show = (code === '1202');
    adv.style.display = show ? 'block' : 'none';
    if(show && typeof populateYearArchiveSelect === 'function'){
      populateYearArchiveSelect();
    }
  }

  document.addEventListener('input', function(e){
    if(e && e.target && e.target.id === 'unlock-code'){
      updateAdvancedControlsVisibility();
    }
  });

  document.addEventListener('DOMContentLoaded', updateAdvancedControlsVisibility);
})();
</script>
</body>
</html>
