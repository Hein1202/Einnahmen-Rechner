<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<title>Einnahmen V217</title>
<style>
body { margin:0; padding:0; }
.container { max-width:600px; margin:0 auto; background:white; padding:20px; }
h1 { margin-top:0; }

#selected-month {
  font-weight:bold;
  font-size:1.6em;
  color:#b30000;
  background:#ffe5e5;
  padding:5px 12px;
  border-radius:8px;
}

#month-nav { font-size:1.4em; margin:10px 0; display:flex; align-items:center; justify-content:space-between; }
.nav { cursor:pointer; font-weight:bold; padding:0 10px; }

table { width:100%; border-collapse:collapse; background:#f5f5dc; }
th, td { border:1px solid black; padding:6px; text-align:center; }

/* Grundlegendes Styling f√ºr Betragsfelder und Trinkgeld */
.amount1,
.amount2,
.amountTip {
  background-color: #f3f4f6;
  box-sizing: border-box;
  padding: 8px;
  border: 1px solid black;
  text-align: center;
  width: 60%;
  max-width: 120px;
  min-width: 60px;
  display: block;
  margin: 0 auto;
}
.toggle-tip {
  margin-left: 4px;
}

/* Zellen der Eingabezeilen oben ausrichten, damit Betrag 1 und Betrag 2
   (inkl. Button) b√ºndig nebeneinander stehen. */
tr.entry-row td {
  vertical-align: top;
}

/* Wrapper von Betrag 2 kompakt halten und neben Betrag 1 platzieren */
.amount2-wrapper {
  display: inline-block;
  vertical-align: top;
  margin: 0;
  padding: 0;
}
.amount1-wrapper {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.amount1-wrapper input.amount1 {
  font-size: 1.08em;
  min-width: 0;
  padding-right: 4px;
}

/* Standardbetrag-Button links neben dem Feld */
.std-amount-btn {
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 1px solid #999;
  background: #ffffff;
  font-size: 0.9em;
  font-weight: 700;
  cursor: pointer;
  display: inline-flex; /* Platz immer reservieren ‚Üí kein Springen */
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  align-items: center;
  justify-content: center;
  padding: 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  transition: background-color 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease, transform 0.08s ease, opacity 0.08s ease;
}

.std-amount-btn:focus-visible {
  outline: 2px solid #93c5fd;
  outline-offset: 2px;
}

.std-amount-btn.visible {
  visibility: visible;
  opacity: 1;
  pointer-events: auto;
}

.std-amount-btn:hover {
  background: #eef2ff;
  border-color: #6b8cff;
  box-shadow: 0 3px 7px rgba(0,0,0,0.16);
  transform: translateY(-1px);
}

.copy-prev-amount {
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 1px solid #999;
  background: #f0f0f0;
  font-size: 0.8em;
  line-height: 1;
  cursor: pointer;
  opacity: 0.9;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

.copy-prev-amount:hover {
  opacity: 1;
  background: #e0e0e0;
}


.amount-error-hint {
  margin-top: 2px;
  font-size: 0.8em;
  color: #b30000;
}


/* Toggle-Button direkt unter dem zweiten Feld, ohne extra Abstand nach oben */
.toggle-amount2 {
  display: inline-block;
  vertical-align: top;
  margin-top: 0;
  font-size: 0.8em;
  padding: 2px 6px;
  cursor: pointer;
}

.empty-input { background-color:lightgray; }
.amount1:not(.empty-input) {
  font-weight: bold;
}

.weekend, .holiday, .customfree {
  background:#ddd;
  font-weight:bold;
  font-style:italic;
}

/* Spezielle Farben f√ºr Beschriftung von Urlaub und Krankheit */
.customfree .day-cell small .label-urlaub {
  color: #2a8f3a;
}
.customfree .day-cell small .label-krank {
  color: #3a5f85;
}
.day-cell { cursor:pointer; font-weight:bold; }

/* Sonntage und Feiertage: Tageszahl + Text in Rot darstellen */
.weekend.sunday .day-cell,
.weekend.sunday .day-cell small,
.holiday .day-cell,
.holiday .day-cell small {
  color: #b30000;
}

/* Druckmodus optimieren */

#main-table th:nth-child(2),
#main-table td:nth-child(2) {
  width: 120px;
}

#main-table th:nth-child(3),
#main-table td:nth-child(3) {
  width: 90px;
}

#main-table th:nth-child(4),
#main-table td:nth-child(4) {
  width: 80px;
}


input[type="text"] {
  border: 1px solid #d1d5db;
  border-radius: 6px;
  padding: 4px 6px;
  box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.08);
  transition: border-color 0.12s ease, box-shadow 0.12s ease, background-color 0.12s ease;
}

input[type="text"]:focus {
  outline: none;
  border-color: #2563eb;
  box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
  background-color: #eff6ff;
}

@media print {
  button, input[type=file] {
    display:none !important;
  }
  body {
    color:black !important;
    background:white !important;
  }
  #selected-month {
    background:white !important;
    color:black !important;
  }
}





.nav-btn {
  font-size: 1.4em;
  padding: 6px 12px;
  margin: 0 10px;
  cursor: pointer;
  font-weight: bold;
  border: 2px solid #444;
  background: #eee;
  border-radius: 6px;
}


/* Scroll button to jump from a day to the monthly overview */
/* Base cell style: empty by default */
.scroll-to-summary {
  cursor: default;
  padding: 0 4px;
  font-size: 0.95em;
}

/* Kreis mit Pfeil */
.scroll-circle {
  display: inline-flex;
  align-items: center;
  justify-content: center;

  cursor: pointer;  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 2px solid #244b79;
  background: #cfe2ff; /* leichtes Blau */
  font-size: 1.3em;
  line-height: 1;
  font-weight: bold;
}

/* Text neben dem Kreis */
.scroll-text {
  margin-left: 4px;
  white-space: nowrap;
}
.scroll-back-wrapper {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  margin-top: 4px;
}
.missing-day-hint-inline {
  margin-top: 6px;
  padding: 8px 10px;
  border: 2px solid #b30000;
  background: #ffecec;
  color: #b30000;
  font-weight: bold;
  border-radius: 6px;
  font-size: 0.9em;
}



/* Highlight auf dem Kreis bei Hover */
.scroll-to-summary:hover .scroll-circle {
  background: #d8eaff;
}

/* Entferne Auf-/Ab-Pfeile (Spinner) in number-Feldern, um den Inhalt komplett anzuzeigen */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.modern-btn {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.95em;
  font-weight: 600;
  background: linear-gradient(135deg, #2563eb, #1d4ed8);
  color: #ffffff;
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.35);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.18s ease;
}

.modern-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.35);
  filter: brightness(1.04);
}

.modern-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.3);
  filter: brightness(0.96);
}

.modern-btn:focus-visible {
  outline: 2px solid #93c5fd;
  outline-offset: 2px;
}
.excel-btn {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.95em;
  font-weight: 600;
  background: linear-gradient(135deg, #22c55e, #16a34a);
  color: #ffffff;
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.35);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.18s ease;
}

.excel-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.35);
  filter: brightness(1.05);
}

.excel-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.3);
  filter: brightness(0.95);
}

.excel-btn:focus-visible {
  outline: 2px solid #bbf7d0;
  outline-offset: 2px;
}

input[type="number"] {
  -moz-appearance: textfield; /* f√ºr Firefox */
}


.bg-blue   { background-color: #e0f0ff; }
.bg-green  { background-color: #e8ffe8; }
.bg-yellow { background-color: #fffbe0; }
.bg-dark   { background-color: #1e1e1e; color: white; }

.bg-darkblue { background-color: #b0c4de; } /* steelblue/light slate blue */

/* √Ñu√üerer Rahmen pro Tag */
tbody[id^="day-"] {
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 10px;
  border-collapse: separate;
  border-spacing: 0;
}

/* Keine Rahmen innerhalb eines Tagesblocks */
tbody[id^="day-"] td,
tbody[id^="day-"] tr {
  border: none !important;
  outline: none !important;
}

/* Inputs bleiben sichtbar, aber dezent */
tbody[id^="day-"] input {
  border: 1px solid #9ca3af;
  border-radius: 6px;
  padding: 4px 6px;
  box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.12);
  background-color: #ffffff;

}


/* Gr√∂√üere Darstellung der Tageszahlen (erste Spalte) */
tbody[id^="day-"] tr:first-child td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Auch Tageszahlen in freien Tagen (z.‚ÄØB. Samstag, Sonntag, Feiertag) gr√∂√üer darstellen */
tr.frei td span.fett {
  font-size: 1.4em;
}


/* Auch regul√§re Tageszahlen gr√∂√üer darstellen */
tbody[id^="day-"] tr td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Tagessumme (rechts unten) und Kundenanzahl fett */
tbody[id^="day-"] tr:last-child td:last-child,
tbody[id^="day-"] tr:last-child td:nth-last-child(2) {
  font-weight: bold;
}


.tg-cell {
  min-width: 60px;
}

.amount1 {
  font-size: 1.08em;
  box-shadow: 0 0 10px rgba(37, 99, 235, 0.65);
  border-radius: 6px;
}
</style>
<script>
// --- Globale Variablen ---
const monthNames = ["Januar","Februar","M√§rz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"];
let now = new Date();
let selMonth = now.getMonth();
let selYear = now.getFullYear();
let selDays = 0;
let holidays = {};

// Erkennung, ob das Ger√§t ein Touch-Ger√§t (Smartphone/Tablet) ist.
const isTouchDevice = ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

// --- Hilfsfunktionen Datum ---
function daysInMonth(y, m){ return new Date(y, m+1, 0).getDate(); }

function fmt(d){
  return d.getFullYear() + "-" +
         String(d.getMonth()+1).padStart(2,"0") + "-" +
         String(d.getDate()).padStart(2,"0");
}
function addDays(d, x){
  let n = new Date(d);
  n.setDate(n.getDate() + x);
  return n;
}

// Ostersonntag nach Gau√ü
function calcEaster(Y){
  let a = Y % 19;
  let b = Math.floor(Y / 100);
  let c = Y % 100;
  let d = Math.floor(b / 4);
  let e = b % 4;
  let f = Math.floor((b + 8) / 25);
  let g = Math.floor((b - f + 1) / 3);
  let h = (19*a + b - d - g + 15) % 30;
  let i = Math.floor(c / 4);
  let k = c % 4;
  let l = (32 + 2*e + 2*i - h - k) % 7;
  let m = Math.floor((a + 11*h + 22*l) / 451);
  let month = Math.floor((h + l - 7*m + 114) / 31);
  let day = ((h + l - 7*m + 114) % 31) + 1;
  return new Date(Y, month - 1, day);
}

function getNRWHolidays(year){
  let easter = calcEaster(year);
  let H = {};
  H[fmt(new Date(year,0,1))]  = "Neujahr";
  H[fmt(new Date(year,4,1))]  = "Tag der Arbeit";
  H[fmt(new Date(year,9,3))]  = "Tag der Deutschen Einheit";
  H[fmt(new Date(year,11,25))] = "1. Weihnachtstag";
  H[fmt(new Date(year,11,26))] = "2. Weihnachtstag";
  H[fmt(new Date(year,10,1))] = "Allerheiligen";
  H[fmt(addDays(easter,-2))]  = "Karfreitag";
  H[fmt(addDays(easter, 1))]  = "Ostermontag";
  H[fmt(addDays(easter,39))]  = "Christi Himmelfahrt";
  H[fmt(addDays(easter,50))]  = "Pfingstmontag";
  H[fmt(addDays(easter,60))]  = "Fronleichnam";
  return H;
}

// --- Design-Helfer ---
function checkInput(input){
  if(!input) return;
  if(input.value === "") input.classList.add("empty-input");
  else input.classList.remove("empty-input");

  const row = input.closest("tr.entry-row");

  // Wenn Betrag 1 ge√§ndert wird und jetzt einen Wert hat,
  // einen evtl. vorhandenen Hinweis bei Betrag 2 in derselben Zeile ausblenden.
  if (row && input.classList.contains("amount1") && input.value !== "") {
    const wrapper2 = row.querySelector(".amount2-wrapper");
    if (wrapper2) {
      const hint = wrapper2.querySelector(".amount-error-hint");
      if (hint) hint.remove();
    }
  }

  // Zus√§tzliche Plausibilit√§tspr√ºfung: Wenn in Betrag 2 ein Wert
  // eingegeben wird, aber Betrag 1 in derselben Zeile leer ist,
  // einen optischen Hinweis unter dem Feld anzeigen und die Eingabe
  // in Betrag 2 zur√ºcknehmen.
  if (row && input.classList.contains("amount2") && input.value !== "") {
    const a1 = row.querySelector(".amount1");
    if (a1 && !a1.value) {
      const wrapper2 = row.querySelector(".amount2-wrapper");
      if (wrapper2) {
        let hint = wrapper2.querySelector(".amount-error-hint");
        if (!hint) {
          hint = document.createElement("div");
          hint.className = "amount-error-hint";
          wrapper2.appendChild(hint);
        }
        hint.textContent = "Bitte zuerst Betrag 1 eingeben.";
      }
      input.value = "";
      input.classList.add("empty-input");
      const day = typeof getDayFromEntryRow === "function"
        ? getDayFromEntryRow(row)
        : null;
      if (day != null) {
        updateDay(day);
      }
      a1.focus();
    }
  }
}

function toggleAmount2(btn, day){
  const wrapper = btn.parentElement.querySelector(".amount2-wrapper");
  const input = wrapper.querySelector(".amount2");
  if(wrapper.style.display === "none" || wrapper.style.display === ""){
    wrapper.style.display = "block";
    btn.textContent = "‚àí Betrag 2";
  } else {
    wrapper.style.display = "none";
    if (input) {
      input.value = "";
      checkInput(input);
    }
    btn.textContent = "+ Betrag 2";
    updateDay(day);
  }
  // Nach √Ñnderung Betrag-2-Status Buttons neu bewerten
  updateAmount2ButtonsVisibility();
}


function toggleTipUI(btn){
  const wrapper = btn.parentElement.querySelector(".amountTip-wrapper");
  const input = wrapper ? wrapper.querySelector(".amountTip") : null;
  if (wrapper && input) {
    if (wrapper.style.display === "none" || wrapper.style.display === "") {
      // Feld einblenden
      wrapper.style.display = "block";
      btn.textContent = "‚àí TG";
      input.focus();
    } else {
      // Feld ausblenden und Wert l√∂schen
      wrapper.style.display = "none";
      input.value = "";
      checkInput(input);
      btn.textContent = "+ TG";
      const row = btn.closest("tr.entry-row");
      const day = getDayFromEntryRow(row);
      if (day !== null) {
        updateDay(day);
      }
    }
  }
  updateAmount2ButtonsVisibility();
}

let currentAmount1Row = null;

// Wird aufgerufen, wenn ein Betrag-1-Feld den Fokus erh√§lt.
// Merkt sich die aktuelle Zeile und aktualisiert die Sichtbarkeit
// der "+ Betrag 2"-Buttons.
function setCurrentAmount1Row(input){
  const row = input.closest("tr.entry-row");
  currentAmount1Row = row || null;
  updateAmount2ButtonsVisibility();
}

// Aktualisiert die Sichtbarkeit aller "+ Betrag 2"-Buttons.
// Grundlogik:
//  - Wenn in einer Zeile Betrag 2 bereits gef√ºllt/aktiv ist ‚Üí Button immer sichtbar.
//  - Sonst: Button nur in der aktuell fokussierten Zeile sichtbar.

function updateAmount2ButtonsVisibility(){
  const rows = document.querySelectorAll("tr.entry-row");
  rows.forEach(row => {
    const btn = row.querySelector(".toggle-amount2");
    const copyBtn = row.querySelector(".copy-prev-amount");
    const stdBtns = row.querySelectorAll(".std-amount-btn");
    const tipBtn = row.querySelector(".toggle-tip");

    // Betrag-2-Schalter: nur in der aktiven Zeile sichtbar
    if (btn) {
      if (row === currentAmount1Row) {
        btn.style.display = "inline-block";
      } else {
        btn.style.display = "none";
      }
    }

    // Wiederhol-Button (‚Ü∫): nur in der aktiven Zeile und nicht in der allerersten Zeile
    if (copyBtn) {
      const allRows = Array.from(document.querySelectorAll('tbody[id^="day-"] tr.entry-row'));
      const isFirstGlobal = allRows.length > 0 && allRows[0] === row;

      if (row === currentAmount1Row) {
        if (!isFirstGlobal) {
          copyBtn.style.display = "inline-block";
        } else {
          copyBtn.style.display = "none";
        }
      } else {
        copyBtn.style.display = "none";
      }
    }

    // Standardbetrag-Buttons (22 / 33): alle in der aktiven Zeile sichtbar
    if (stdBtns && stdBtns.length) {
      stdBtns.forEach(stdBtn => {
        if (row === currentAmount1Row) {
          stdBtn.classList.add("visible");
        } else {
          stdBtn.classList.remove("visible");
        }
      });
    }

    // TG-Button: nur in der aktiven Zeile sichtbar
    if (tipBtn) {
      if (row === currentAmount1Row) {
        tipBtn.style.display = "inline-block";
      } else {
        tipBtn.style.display = "none";
      }
    }
  });
}


function handleEnter(e){
  // Auf Desktop funktioniert Enter normal, auf vielen Smartphones sendet die
  // Action-Taste der Bildschirmtastatur jedoch "Next"/Tab. Wir behandeln
  // deshalb sowohl Enter als auch Tab (keyCode 13 bzw. 9) als Ausl√∂ser.
  const k = e.key;
  const code = e.keyCode || e.which;
  const isActionKey = (k === "Enter" || k === "Tab" || code === 13 || code === 9);

  if(isActionKey){
    e.preventDefault();
    const currentRow = e.target.closest("tr.entry-row");
    if(!currentRow) return;
    const tbody = currentRow.parentElement;
    if(!tbody || !tbody.id || !tbody.id.startsWith("day-")) return;

    const rows = Array.from(tbody.querySelectorAll("tr.entry-row"));
    const idx = rows.indexOf(currentRow);
    if(idx === -1) return;

    // Wenn es eine weitere Zeile im selben Tag gibt ‚Üí dorthin springen
    if(idx < rows.length - 1){
      const nextRow = rows[idx + 1];
      const nextInput = nextRow.querySelector("input.amount1");
      if(nextInput){
        nextInput.focus();
        if(typeof nextInput.select === "function"){
          nextInput.select();
        }
      }
    } else {
      // Letzte Zeile dieses Tages: neue Zeile anlegen und dorthin springen
      const dayStr = tbody.id.split("-")[1];
      const day = parseInt(dayStr, 10);
      if(!isNaN(day)){
        addRow(day);
        const newRows = tbody.querySelectorAll("tr.entry-row");
        const lastRow = newRows[newRows.length - 1];
        const input = lastRow.querySelector("input.amount1");
        if(input){
          input.focus();
          if(typeof input.select === "function"){
            input.select();
          }
        }
      }
    }
  }
}

// Fallback speziell f√ºr Smartphones: Wenn der Benutzer das letzte
// Betragsfeld eines Tages verl√§sst und dort ein Wert steht, wird automatisch
// eine neue Zeile f√ºr diesen Tag angelegt.
function handleExit(e){
  // Fallback nur auf Touch-Ger√§ten aktivieren, damit auf Desktop
  // ein Mausklick auf eine freie Stelle keine neue, leere Zeile erzeugt.
  if (!isTouchDevice) return;
  const input = e.target;
  const currentRow = input.closest("tr.entry-row");
  if(!currentRow) return;
  const tbody = currentRow.parentElement;
  if(!tbody || !tbody.id || !tbody.id.startsWith("day-")) return;

  const rows = Array.from(tbody.querySelectorAll("tr.entry-row"));
  const idx = rows.indexOf(currentRow);
  if(idx === -1 || idx < rows.length - 1) return; // nicht letzte Zeile

  const a1 = currentRow.querySelector("input.amount1");
  const a2 = currentRow.querySelector("input.amount2");
  const hasValue =
    (a1 && a1.value !== "") ||
    (a2 && a2.value !== "");
  if(!hasValue) return; // Zeile leer ‚Üí nichts tun

  const dayStr = tbody.id.split("-")[1];
  const day = parseInt(dayStr, 10);
  if(isNaN(day)) return;

  addRow(day);
  const newRows = tbody.querySelectorAll("tr.entry-row");
  const lastRow = newRows[newRows.length - 1];
  const firstInput = lastRow.querySelector("input.amount1");
  if(firstInput){
    firstInput.focus();
    if(typeof firstInput.select === "function"){
      firstInput.select();
    }
  }
}

// Enter/Tab auch im Trinkgeld-Feld wie in Betrag 1/2 behandeln
document.addEventListener('keydown', function(e) {
  const t = e.target;
  if (t && t.classList && t.classList.contains('amountTip')) {
    handleEnter(e);
  }
});

// Eigene freie Tage speichern / lesen. Bei einem Klick kann der Benutzer w√§hlen,
// ob der Tag als Urlaubstag oder Krankheitstag markiert werden soll. Bei erneutem
// Klick wird die Markierung entfernt. Die Auswahl wird unter dem Schl√ºssel
// "cf-YYYY-MM-DD" im localStorage gespeichert und der Wert gibt die Art des
// freien Tages an ("urlaub" oder "krank").
function toggleFreeDay(day){
  const key = "cf-" + selYear + "-" + selMonth + "-" + day;
  const current = localStorage.getItem(key);

  let next;
  if(current === null){
    next = "urlaub";
  } else if(current === "urlaub"){
    next = "krank";
  } else if(current === "krank"){
    next = null;
  }

  if(next === null){
    localStorage.removeItem(key);
  } else {
    localStorage.setItem(key, next);
  }

  updateMonth();  // neu aufbauen
}

// Liefert den Typ des eigenen freien Tages ("urlaub", "krank") oder null, wenn
// der Tag kein eigener freier Tag ist.
function getFreeDayType(day){
  return localStorage.getItem("cf-" + selYear + "-" + selMonth + "-" + day);
}

// Pr√ºft, ob der Tag als eigener freier Tag markiert ist (unabh√§ngig vom Typ).
function isFreeDay(day){
  return getFreeDayType(day) !== null;
}

// Zus√§tzliche Helfer f√ºr die Erkennung fehlender Eintr√§ge im vorherigen Arbeitstag.

// Pr√ºft, ob ein bestimmter Tag (im aktuellen Monat) ein relevanter Arbeitstag ist,
// d.h. kein Wochenende, kein Feiertag und kein als frei (Urlaub/Krank) markierter Tag.
function isRelevantWorkday(day) {
  if (day < 1 || day > selDays) return false;
  const date = new Date(selYear, selMonth, day);
  const weekday = date.toLocaleDateString("de-DE", { weekday: "long" }).toLowerCase();
  if (weekday === "samstag" || weekday === "sonntag") return false;
  const ds = fmt(date);
  if (holidays && holidays[ds]) return false;
  if (isFreeDay(day)) return false;
  return true;
}

// Sucht den letzten relevanten Arbeitstag vor dem angegebenen Tag.
function findPreviousWorkday(currentDay) {
  for (let d = currentDay - 1; d >= 1; d--) {
    if (isRelevantWorkday(d)) return d;
  }
  return null;
}

// Pr√ºft, ob an dem angegebenen Tag mindestens ein Eintrag mit Betrag > 0 existiert.
function dayHasAnyEntry(day) {
  const tbody = document.getElementById("day-" + day);
  if (!tbody) return false;
  const rows = tbody.querySelectorAll("tr.entry-row");
  for (const row of rows) {
    const a1Str = row.querySelector(".amount1")?.value || "";
    const a2Str = row.querySelector(".amount2")?.value || "";
    const tipStr = row.querySelector(".amountTip")?.value || "";
    const num1 = parseFloat(String(a1Str).replace(",", "."));
    const num2 = parseFloat(String(a2Str).replace(",", "."));
    const numTip = parseFloat(String(tipStr).replace(",", "."));
    if ((!isNaN(num1) && num1 > 0) ||
        (!isNaN(num2) && num2 > 0) ||
        (!isNaN(numTip) && numTip > 0)) {
      return true;
    }
  }
  return false;
}

function hasAnyDataInMonth() {
  for (let d = 1; d <= selDays; d++) {
    if (dayHasAnyEntry(d)) return true;
  }
  return false;
}

function updateBackArrowLabel() {
  const wrapper = document.querySelector('.scroll-back-wrapper');
  if (!wrapper) return;
  const textSpan = wrapper.querySelector('.scroll-text');
  if (!textSpan) return;

  if (hasAnyDataInMonth()) {
    textSpan.textContent = " zum letzten Eintrag";
    wrapper.title = "Zum letzten Eintrag springen";
  } else {
    textSpan.textContent = " zur√ºck zum Start";
    wrapper.title = "Zur√ºck zum Start";
  }
}

let lastMissingDay = null;
let lastMissingHintRow = null;

// Zeigt einen Hinweis inline unter dem aktuellen Tag an, dass f√ºr einen
// vorherigen Tag keine Eintr√§ge vorhanden sind und bietet an, diesen
// als Urlaubstag / Krankheitstag zu markieren oder zu ihm zu springen.
// missingDay  = der Tag, an dem keine Eintr√§ge vorhanden sind
// currentDay  = der Tag, an dem gerade eine Eingabe vorgenommen wurde
function showMissingDayHint(missingDay, currentDay) {
  lastMissingDay = missingDay;

  // vorhandenen Inline-Hinweis entfernen
  hideMissingDayHint();

  const currentTbody = document.getElementById("day-" + currentDay);
  if (!currentTbody) return;

  const dateStr = String(missingDay).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;

  const tr = document.createElement("tr");
  tr.className = "missing-day-hint-inline-row";
  const td = document.createElement("td");
  td.colSpan = 5;
  td.innerHTML =
    '<div class="missing-day-hint-inline">' +
    'Hinweis: Am ' + dateStr + ' wurde kein Eintrag gemacht.<br/>' +
    '<button type="button" onclick="markMissingDayAs(\'urlaub\')">Als Urlaubstag markieren</button> ' +
    '<button type="button" onclick="markMissingDayAs(\'krank\')">Als Krankheitstag markieren</button>' +
    '</div>';
  tr.appendChild(td);

  // Hinweis direkt vor der Tagessummen-Zeile einf√ºgen, falls vorhanden
  const summaryRow = currentTbody.querySelector("tr.day-summary");
  if (summaryRow) {
    currentTbody.insertBefore(tr, summaryRow);
  } else {
    currentTbody.appendChild(tr);
  }

  lastMissingHintRow = tr;
}

function hideMissingDayHint() {
  if (lastMissingHintRow && lastMissingHintRow.parentNode) {
    lastMissingHintRow.parentNode.removeChild(lastMissingHintRow);
  }
  lastMissingHintRow = null;
}

// Markiert den zuletzt gemeldeten fehlenden Tag als Urlaub oder Krank
// und baut den Monat neu auf.
function markMissingDayAs(type) {
  if (!lastMissingDay) return;
  const key = "cf-" + selYear + "-" + selMonth + "-" + lastMissingDay;
  if (type === "urlaub" || type === "krank") {
    localStorage.setItem(key, type);
  }
  hideMissingDayHint();
  updateMonth();
}

// Scrollt zum zuletzt gemeldeten fehlenden Tag.
function scrollToMissingDay() {
  if (!lastMissingDay) return;
  const tbody = document.getElementById("day-" + lastMissingDay);
  if (!tbody) return;
  const rect = tbody.getBoundingClientRect();
  const target = rect.top + window.pageYOffset - 60;
  window.scrollTo({ top: target < 0 ? 0 : target, behavior: "smooth" });
}

// Wird nach der Aktualisierung eines Tages aufgerufen, um zu pr√ºfen,
// ob der vorherige relevante Arbeitstag leer ist.
function checkPreviousWorkdayForMissingEntries(day) {
  if (day <= 1) return;
  const prev = findPreviousWorkday(day);
  if (!prev) return;
  if (!dayHasAnyEntry(prev)) {
    showMissingDayHint(prev, day);
  } else if (lastMissingDay === prev) {
    // Falls der vorherige Tag inzwischen Eintr√§ge hat, Hinweis ggf. ausblenden
    hideMissingDayHint();
  }
}

// Monatsnavigation
function prevMonth(){
  selMonth--;
  if(selMonth < 0){ selMonth = 11; selYear--; }
  updateMonth();
}
function nextMonth(){
  selMonth++;
  if(selMonth > 11){ selMonth = 0; selYear++; }
  updateMonth();
}

function updateMonth(){
  document.getElementById("selected-month").innerText =
    monthNames[selMonth] + " " + selYear;

  selDays = daysInMonth(selYear, selMonth);
  holidays = getNRWHolidays(selYear);

  buildTable();
  loadAllDays();
  updateTotals();
}

// Tabelle aufbauen
function buildTable(){
  const table = document.getElementById("main-table");
  const tfoot = document.querySelector("tfoot");
  document.querySelectorAll("tbody.dayblock").forEach(e => e.remove());

  for(let day = 1; day <= selDays; day++){
    const date = new Date(selYear, selMonth, day);
    const weekday = date.toLocaleDateString("de-DE",{weekday:"long"}).toLowerCase();
    const weekdayLabel = weekday.charAt(0).toUpperCase() + weekday.slice(1);
    const ds = fmt(date);
    const isHoliday = (holidays[ds] != null);
    const isWeekend = (weekday === "samstag" || weekday === "sonntag");
    const isSunday  = (weekday === "sonntag");
    // Den Typ des eigenen freien Tages ermitteln ("urlaub", "krank" oder null)
    const freeType = getFreeDayType(day);
    const isFree = freeType !== null;

    let tb = document.createElement("tbody");
    tb.classList.add("dayblock");
    tb.id = "day-" + day;

    if(isHoliday){
      const holidayName = holidays[ds] || "Feiertag";
      tb.innerHTML = `<tr class="holiday">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${weekdayLabel} ‚Äì ${holidayName}</small></td>
        <td colspan="4">Kein Arbeitstag</td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else if(isWeekend){
      const weekendClass = isSunday ? "weekend sunday" : "weekend";
      tb.innerHTML = `<tr class="${weekendClass}">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${weekdayLabel}</small></td>
        <td colspan="4">Kein Arbeitstag</td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else if(isFree){
      // Je nach Typ des eigenen freien Tages eine passende Beschriftung w√§hlen
      const label = freeType === "urlaub"
        ? '<span class="label-urlaub">üå¥ Urlaubstag</span>'
        : (freeType === "krank"
           ? '<span class="label-krank">ü§í Krankheitstag</span>'
           : "Eigener freier Tag");
      // Bei eigenen freien Tagen soll die Beschriftung "Kein Arbeitstag" entfallen.
      tb.innerHTML = `<tr class="customfree">
        <td class="day-cell" onclick="toggleFreeDay(${day})">${day}<br><small>${label}</small></td>
        <td colspan="4"></td>
      </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    } else {
      tb.innerHTML = `
        <tr class="entry-row">
          <td class="day-cell" onclick="toggleFreeDay(${day})">${day}</td>
          <td><div class="amount1-wrapper"><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 16, ${day})" title="16 ‚Ç¨ einf√ºgen">16</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 22, ${day})" title="22 ‚Ç¨ einf√ºgen">22</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 33, ${day})" title="33 ‚Ç¨ einf√ºgen">33</button><input class="amount1 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)"></div></td>
          <td>
            <div class="amount2-wrapper" style="display:none;">
              <input class="amount2 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)">
            </div>
            <button type="button" class="toggle-amount2" style="display:none;" onclick="toggleAmount2(this, ${day})">+ Betrag 2</button>
            
          </td>
          <td class="tg-cell">
                        <div class="amountTip-wrapper" style="display:none;">
              <input class="amountTip empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); (function(el){ const row = el.closest(\'tr.entry-row\'); const d = getDayFromEntryRow(row); if(d !== null){ updateDay(d); } })(this)">
            </div>
<button type="button" class="toggle-tip" style="display:none;" style="display:none;" onclick="toggleTipUI(this)">+ TG</button>
          </td>
          <td class="scroll-to-summary"></td>
          <td></td>
        </tr>
        <tr class="day-summary">
          <td></td><td></td>
          <td class="scroll-to-summary"></td>
          <td id="sum-${day}"></td>
          <td id="cnt-${day}"></td>
        </tr>
        `;
    }
    table.insertBefore(tb, tfoot);
  }
}

function addRow(day){
  const tb = document.getElementById("day-" + day);
  const tr = document.createElement("tr");
  tr.classList.add("entry-row");
  tr.innerHTML = `
    <td></td>
    <td><div class="amount1-wrapper"><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 16, ${day})" title="16 ‚Ç¨ einf√ºgen">16</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 22, ${day})" title="22 ‚Ç¨ einf√ºgen">22</button><button type="button" class="std-amount-btn" onclick="setStandardAmountForRow(this, 33, ${day})" title="33 ‚Ç¨ einf√ºgen">33</button><input class="amount1 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)"></div></td>
    <td>
      <div class="amount2-wrapper" style="display:none;">
        <input class="amount2 empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); updateDay(${day})" onfocus="setCurrentAmount1Row(this)" onkeydown="handleEnter(event)" onblur="handleExit(event)">
      </div>
      <button type="button" class="toggle-amount2" style="display:none;" onclick="toggleAmount2(this, ${day})">+ Betrag 2</button>
      
    </td>
    <td class="tg-cell">
                  <div class="amountTip-wrapper" style="display:none;">
              <input class="amountTip empty-input" type="number" step="0.01" lang="de" enterkeyhint="enter" oninput="checkInput(this); (function(el){ const row = el.closest(\'tr.entry-row\'); const d = getDayFromEntryRow(row); if(d !== null){ updateDay(d); } })(this)">
            </div>
<button type="button" class="toggle-tip" style="display:none;" style="display:none;" onclick="toggleTipUI(this)">+ TG</button>
    </td>
    <td class="scroll-to-summary"></td>
    <td></td>`;
  const summary = tb.querySelector("tr.day-summary");
  if(summary){
    tb.insertBefore(tr, summary);
  } else {
    tb.appendChild(tr);
  }

  // Move the scroll indicator to the newly added row
  if (typeof updateScrollArrow === 'function') {
    updateScrollArrow(tr);
  }
}

// Schl√ºssel f√ºr localStorage
function dayKey(day){
  return "day-" + selYear + "-" + selMonth + "-" + day;
}

// Tag neu berechnen und speichern
function updateDay(day){
  let sum = 0;
  let customers = 0;
  document.querySelectorAll("#day-" + day + " .entry-row").forEach(row => {
    const a1 = parseFloat(row.querySelector(".amount1")?.value) || 0;
    const a2 = parseFloat(row.querySelector(".amount2")?.value) || 0;
    const tip = parseFloat(row.querySelector(".amountTip")?.value) || 0;
    if(a1 > 0 || a2 > 0 || tip > 0) customers++;
    sum += a1 + a2 + tip;
  });
  document.getElementById("sum-" + day).innerText = sum > 0 ? sum.toFixed(2) : "";
  document.getElementById("cnt-" + day).innerText = customers > 0 ? customers : "";

  saveDay(day);
  updateTotals();

  // Wenn an diesem Tag nun eine Summe > 0 vorhanden ist, pr√ºfen,
  // ob der vorherige Arbeitstag ohne Eintrag ist.
  if (sum > 0) {
    checkPreviousWorkdayForMissingEntries(day);
  }

  // Falls der aktuell bearbeitete Tag selbst der zuletzt gemeldete
  // fehlende Tag ist und nun einen Eintrag hat, den Hinweis ausblenden.
  if (typeof lastMissingDay !== "undefined" && lastMissingDay === day) {
    if (dayHasAnyEntry(day)) {
      hideMissingDayHint();
    }
  }
}

function saveDay(day){
  const rows = [...document.querySelectorAll("#day-" + day + " .entry-row")].map(row => ({
    amount1: row.querySelector(".amount1")?.value || "",
    amount2: row.querySelector(".amount2")?.value || "",
    amountTip: row.querySelector(".amountTip")?.value || ""
  }));
  localStorage.setItem(dayKey(day), JSON.stringify(rows));
}

function loadDay(day){
  const raw = localStorage.getItem(dayKey(day));
  if(!raw) return;
  const rows = JSON.parse(raw);
  const tb = document.getElementById("day-" + day);
  if(!tb) return;

  rows.forEach((r, idx) => {
    if(idx > 0) addRow(day);
    const row = tb.querySelectorAll(".entry-row")[idx];
    const a1 = row.querySelector(".amount1");
    const a2 = row.querySelector(".amount2");
    const tip = row.querySelector(".amountTip");
    const wrapper = row.querySelector(".amount2-wrapper");
    const toggleBtn = row.querySelector(".toggle-amount2");
    const tipWrapper = row.querySelector(".amountTip-wrapper");
    const tipBtn = row.querySelector(".toggle-tip");

    // Kompatibilit√§t: sowohl amount1/amount2 als auch a1/a2 akzeptieren
    a1.value = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
    a2.value = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
    if (tip) {
      tip.value = r.amountTip !== undefined ? r.amountTip : "";
    }

    checkInput(a1);
    checkInput(a2);
    if (tip) checkInput(tip);

    if(wrapper){
      if(a2.value !== ""){
        wrapper.style.display = "block";
        if(toggleBtn) toggleBtn.textContent = "‚àí Betrag 2";
      } else {
        wrapper.style.display = "none";
        if(toggleBtn) toggleBtn.textContent = "+ Betrag 2";
      }
    }

    if (tipWrapper && tip) {
      if (tip.value !== "") {
        tipWrapper.style.display = "block";
        if (tipBtn) tipBtn.textContent = "‚àí TG";
      } else {
        tipWrapper.style.display = "none";
        if (tipBtn) tipBtn.textContent = "+ TG";
      }
    }
  });

  updateDay(day);
}

function loadAllDays(){
  for(let d = 1; d <= selDays; d++){
    loadDay(d);
  }
  // Nach dem Laden aller Tage Buttons f√ºr Betrag 2 korrekt initialisieren
  updateAmount2ButtonsVisibility();
}

// Gesamtsummen
function updateTotals(){
  let total = 0;
  let totalCustomers = 0;
  let printedTotal = 0;
  for(let d = 1; d <= selDays; d++){
    const s = parseFloat(document.getElementById("sum-" + d)?.innerText) || 0;
    const c = parseInt(document.getElementById("cnt-" + d)?.innerText) || 0;
    total += s;
    totalCustomers += c;
  }
  document.getElementById("grand-total").innerText = total.toFixed(2);
  const grandCustomersEl = document.getElementById("grand-customers");
  if (grandCustomersEl) grandCustomersEl.innerText = totalCustomers;

  const net = total / 1.19;
  document.getElementById("net-total").innerText = net.toFixed(2);
  document.getElementById("tax-total").innerText = (total - net).toFixed(2);

  // Beschriftung des Zur√ºck-Pfeils abh√§ngig davon, ob Daten vorhanden sind
  updateBackArrowLabel();
}

// JSON Export / Import
function exportJSON(){
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {}
  };

  for(let d = 1; d <= selDays; d++){
    const key = dayKey(d);
    const raw = localStorage.getItem(key);
    if(raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if(freeVal) data.free[cf] = freeVal;
  }

  // Standard-Dateinamen vorschlagen
  const defaultName = "einnahmen_" + selYear + "-" + String(selMonth+1).padStart(2,"0") + ".json";

  // Hinweis, wo gespeichert wird, und M√∂glichkeit zur Umbenennung
  const message = "Die Datei wird in Ihrem Standard-Download-Ordner gespeichert (z.B. 'Downloads').\n\n"
    + "Vorgeschlagener Dateiname:\n" + defaultName + "\n\n"
    + "Sie k√∂nnen den Dateinamen hier √§ndern oder einfach mit OK best√§tigen.";

  let filename = prompt(message, defaultName);
  if (filename === null) {
    // Benutzer hat Abbrechen gew√§hlt ‚Üí nicht speichern
    return;
  }
  filename = filename.trim();
  if (!filename) {
    filename = defaultName;
  }
  if (!filename.toLowerCase().endsWith(".json")) {
    filename += ".json";
  }

  const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function importJSON(ev){
  const file = ev.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try{
      const data = JSON.parse(e.target.result);
      if(data.days){
        for(const key in data.days){
          localStorage.setItem(key, JSON.stringify(data.days[key]));
        }
      }
      if(data.free){
        for(const key in data.free){
          const val = data.free[key];
          // √Ñltere Exporte speicherten nur "1" ‚Üí standardm√§√üig als "urlaub" interpretieren
          if(val === 1 || val === "1" || val === true){
            localStorage.setItem(key, "urlaub");
          } else if(val === "urlaub" || val === "krank") {
            localStorage.setItem(key, val);
          } else {
            // Unbekannte Werte ebenfalls als Urlaub behandeln, damit zyklisches Umschalten funktioniert
            localStorage.setItem(key, "urlaub");
          }
        }
      }
      alert("Import erfolgreich. Seite wird neu geladen.");
      location.reload();
    }catch(err){
      alert("Fehler beim Import: " + err.message);
    }
  };
  reader.readAsText(file);
}

// Alle gespeicherten Daten l√∂schen
function clearAllData(){
  // Hinweis mit Backup-Info und Bezug auf den aktuellen Monat
  const monthLabel = (selMonth + 1).toString().padStart(2, "0") + "." + selYear;
  const confirmMsg =
    "Es wird jetzt eine Sicherungsdatei f√ºr den aktuell ausgew√§hlten Monat (" + monthLabel + ") erstellt,\n" +
    "und anschlie√üend werden alle Daten dieses Monats gel√∂scht.\n\n" +
    "Fortfahren?";

  if (!confirm(confirmMsg)) {
    return;
  }

  // Zuerst automatische Sicherung des aktuellen Monats als JSON
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {}
  };

  for (let d = 1; d <= selDays; d++) {
    const key = dayKey(d);
    const raw = localStorage.getItem(key);
    if (raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if (freeVal) data.free[cf] = freeVal;
  }

  const backupName = "backup_einnahmen_" +
    selYear + "-" + String(selMonth + 1).padStart(2, "0") + ".json";

  try {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = backupName;
    a.click();
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error("Backup konnte nicht erstellt werden:", e);
  }

  // Danach nur die Daten des aktuellen Monats aus dem Speicher entfernen
  for (let d = 1; d <= selDays; d++) {
    const key = dayKey(d);
    localStorage.removeItem(key);
    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    localStorage.removeItem(cf);
  }
  localStorage.removeItem("totalTip");

  alert("Backup erstellt. Alle Daten f√ºr den Monat " + monthLabel + " wurden gel√∂scht.");
  location.reload();
}


// CSV Export
function exportCSV(){
  let lines=["Tag;Betrag1;Betrag2"];
  for(let d=1; d<=selDays; d++){
    let rows = document.querySelectorAll("#day-"+d+" .entry-row");
    rows.forEach(r=>{
      let a1 = r.querySelector(".amount1")?.value || "";
      let a2 = r.querySelector(".amount2")?.value || "";
      lines.push(`${d};${a1};${a2}`);
    });
  }
  let blob=new Blob([lines.join("\n")],{type:"text/csv"});
  let url=URL.createObjectURL(blob);
  let a=document.createElement("a");
  a.href=url;
  a.download="einnahmen.csv";
  a.click();
  URL.revokeObjectURL(url);
}

</script>
<style>
/*
 * Im Druckmodus wird nur der Bereich "#reduced-print" ausgegeben. Auf einigen
 * Mobilger√§ten kann "visibility: hidden" dazu f√ºhren, dass leere Seiten
 * entstehen, da der verborgene Inhalt weiterhin Platz reserviert. Daher
 * verwenden wir "display: none" f√ºr alle Elemente au√üer dem Ausdrucksbereich
 * und blenden diesen explizit √ºber "display: block" ein. Zus√§tzlich sorgen
 * wir f√ºr eine klare Formatierung (monospace‚ÄëSchrift) und setzen Farbe und
 * Hintergrund, damit die PDF‚ÄëDarstellung auf Smartphones korrekt ist.
 */
@media print {
  /* Alle Elemente standardm√§√üig ausblenden */
  body * {
    display: none !important;
  }
  /* Den Ausdrucksbereich und seine Kinder sichtbar machen */
  #reduced-print, #reduced-print * {
    display: block !important;
  }
  #reduced-print {
    position: absolute;
    left: 0;
    top: 0;
    font-family: monospace;
    white-space: pre;
    font-size: 12pt;
    color: black !important;
    background: white !important;
  }
}

/* √Ñu√üerer Rahmen pro Tag */
tbody[id^="day-"] {
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 10px;
  border-collapse: separate;
  border-spacing: 0;
}

/* Keine Rahmen innerhalb eines Tagesblocks */
tbody[id^="day-"] td,
tbody[id^="day-"] tr {
  border: none !important;
  outline: none !important;
}

/* Inputs bleiben sichtbar, aber dezent */
tbody[id^="day-"] input {
  border: 1px solid #ccc;
}


/* Gr√∂√üere Darstellung der Tageszahlen (erste Spalte) */
tbody[id^="day-"] tr:first-child td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Auch Tageszahlen in freien Tagen (z.‚ÄØB. Samstag, Sonntag, Feiertag) gr√∂√üer darstellen */
tr.frei td span.fett {
  font-size: 1.4em;
}


/* Auch regul√§re Tageszahlen gr√∂√üer darstellen */
tbody[id^="day-"] tr td:first-child {
  font-size: 1.4em;
  font-weight: bold;
}


/* Tagessumme (rechts unten) und Kundenanzahl fett */
tbody[id^="day-"] tr:last-child td:last-child,
tbody[id^="day-"] tr:last-child td:nth-last-child(2) {
  font-weight: bold;
}

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script></head>
<body class="bg-darkblue" onload="updateMonth()">
<div class="container">
<h1>Einnahmen V217</h1>
<div id="month-nav">
<button class="nav-btn" onclick="prevMonth()">‚óÑ</button>
<span id="selected-month"></span><span id="month-lock-toggle" onclick="toggleLock()" style="cursor:pointer; font-size: 1.4em; margin-left: 10px;" title="Monat bearbeiten/sperren">üîì</span>
<button class="nav-btn" onclick="nextMonth()">‚ñ∫</button>
</div>
<table id="main-table">
<thead>
<tr>
<th>Tag</th>
<th>Betrag 1</th>
<th>Betrag 2</th><th>TG</th>
<th>Summe</th>
<th>Kunden</th>
</tr>
</thead>
<tfoot></tfoot>
<tr>
<!-- Beschriftung links und Gesamtzahl der Kunden in der letzten Spalte -->
<!-- Der Text "Gesamtanzahl¬†Kunden:" wird bewusst etwas kleiner dargestellt, bleibt aber schwarz -->
<td colspan="4" style="text-align: right;
             font-weight: normal;
             color: #000;
             font-size: 0.8em;
             font-style: italic;">
    Gesamtanzahl¬†Kunden:
  </td>
<td id="grand-customers" style="font-weight: bold;">0</td>
</tr>
</table>

<div style="margin-top:20px;">
  <div id="primary-controls" style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
    <button class="modern-btn" onclick="generateReducedPrint()">üñ®Ô∏è Reduzierter Druck</button>
    <button class="modern-btn" onclick="exportJSON()">Datei speichern</button>
  </div>

  <!-- Schnell-Zur√ºck: immer sichtbar -->
  <div style="margin-top:4px; text-align:right; padding-right:10px;">
  <span class="scroll-back-wrapper" title="Zum letzten Eintrag springen">
    <span class="scroll-circle">‚Üë</span><span class="scroll-text"> zum letzten Eintrag</span>
  </span>
</div>

  <div id="advanced-controls" style="display:none; margin-top:10px;">
    
<input accept="application/json" id="data-file-input" onchange="importJSON(event)" style="display:none;" type="file"/>
<button onclick="document.getElementById('data-file-input').click()">Datei laden</button>
<div style="display:inline-block; margin-left:10px;">
  <button onclick="clearAllData()">Alle Daten l√∂schen</button>
</div>


<div style="margin-top:10px;">
  <label for="quarter-select">Quartal:</label>
  <select id="quarter-select">
    <option value="1">Q1 (Jan‚ÄìM√§r)</option>
    <option value="2">Q2 (Apr‚ÄìJun)</option>
    <option value="3">Q3 (Jul‚ÄìSep)</option>
    <option value="4">Q4 (Okt‚ÄìDez)</option>
  </select>
  <div style="display:inline-block; margin-left:10px;">
    <button class="modern-btn" onclick="generateQuarterReducedPrint()">üñ®Ô∏è Quartal drucken</button>
    <br/>
    <button class="modern-btn" onclick="generateYearOverview()" style="margin-top:6px;">üßÆ Jahres√ºbersicht drucken</button>
  </div>
  <div style="display:inline-block; margin-left:10px;">
    <button class="excel-btn" onclick="exportQuarterExcel()">üìä Quartal Excel</button>
    <br/>
    <button class="excel-btn" onclick="exportExcel()" style="margin-top:6px;">üìä Excel speichern</button>
  </div>
</div>

  </div>

  <div id="admin-code-wrapper" style="margin-top:8px; text-align:right; padding-right:10px;">
    <label for="unlock-code" style="font-size:0.9em; font-weight:bold;">Code:</label>
    <input id="unlock-code" type="password" inputmode="numeric" maxlength="4"
           style="width:90px; text-align:center; margin-left:6px; padding:4px 6px;"
           placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="off" />
    <span style="font-size:0.85em; margin-left:6px; opacity:0.85;">(weitere Funktionen)</span>
  </div>
</div>
<div id="onscreen-totals" style="margin-top:20px;">
<h3>Monats√ºbersicht</h3>
<table>
<tr><th>Gesamtsumme</th><td id="grand-total"></td></tr>
<tr><th>Netto</th><td id="net-total"></td></tr>
<tr><th>MwSt</th><td id="tax-total"></td></tr>
</table>
</div>
<div class="print-summary" style="display:none;">
<h3>Monats√ºbersicht (Druck)</h3>
<table>
<tr><th>Gesamtsumme</th><td id="grand-total-print"></td></tr>
<tr><th>Netto</th><td id="net-total-print"></td></tr>
<tr><th>MwSt</th><td id="tax-total-print"></td></tr>
</table>
</div>
</div>
<div id="reduced-print" style="display:none;"></div>
<script>
/**
 * Erzeugt einen einfachen Ausdruck der Tages- und Monats√ºbersicht.
 * Diese Funktion sammelt alle Eintr√§ge, summiert sie, erzeugt eine
 * textbasierte Tabelle und √∂ffnet den Browser-Druckdialog. Es wird
 * au√üerdem die Gesamtanzahl aller Kunden am Monatsende ausgegeben.
 */

function getSelectedQuarter() {
  const sel = document.getElementById("quarter-select");
  let q = sel ? parseInt(sel.value, 10) : NaN;
  if (!(q >= 1 && q <= 4)) {
    q = Math.floor(selMonth / 3) + 1;
  }
  return q;
}

function getQuarterMonths(q) {
  const start = (q - 1) * 3;
  return [start, start + 1, start + 2];
}

function generateQuarterReducedPrint() {
  const q = getSelectedQuarter();
  const months = getQuarterMonths(q);
  const year = selYear;
  let output = "";
  let total = 0;
  let totalCustomers = 0;
  let printedTotal = 0;

  months.forEach(m => {
    output += "Einnahmen " + monthNames[m] + " " + year + "\n\n";
    const days = daysInMonth(year, m);
    for (let d = 1; d <= days; d++) {
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      const freeKey = "cf-" + year + "-" + m + "-" + d;
      const freeType = localStorage.getItem(freeKey);

      const hasEntries = rows && rows.some(r => {
        const a1 = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
        const a2 = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
        const tip = r.amountTip !== undefined ? r.amountTip : "";
        return (a1 && parseFloat(String(a1).replace(",", ".")) > 0) ||
               (a2 && parseFloat(String(a2).replace(",", ".")) > 0) ||
               (tip && parseFloat(String(tip).replace(",", ".")) > 0);
      });

      if (!hasEntries && freeType) {
        const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank" ? "Krankheitstag" : "Eigener freier Tag");
        output += dateStr.padEnd(12) + label + "\n\n";
        continue;
      }

      let tagSum = 0;
      let kunden = 0;
      let zeilen = [];

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));
          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);
          if (sumVal > 0) {
            kunden++;
            const fmt = n => n.toFixed(2).replace(".", ",");
            const formattedSum = fmt(sumVal);
            const fmt1 = !isNaN(num1) ? fmt(num1) : "";
            const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
            const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";
            let parts = [];
            if (fmt1) parts.push(fmt1);
            if (fmt2) parts.push(fmt2);
            if (fmtTip) parts.push(fmtTip);
            let line;
            if (parts.length > 1) {
              line = formattedSum.padStart(10) + "   " + parts.join(" + ");
            } else {
              line = formattedSum.padStart(10);
            }
            zeilen.push(line);
            tagSum += sumVal;
          }
        });
      }

      if (tagSum > 0) {
        const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
        const maxLines = Math.max(zeilen.length, 1);
        for (let i = 0; i < maxLines; i++) {
          const datum = i === 0 ? dateStr.padEnd(12) : " ".repeat(12);
          const einnahme = zeilen[i] || "";
          output += datum + einnahme + "\n";
        }
        output += " ".repeat(12) + "----------\n";
        output += " ".repeat(12) + tagSum.toFixed(2).replace(".", ",").padStart(10) + "   |   " + kunden + " Kunden\n\n";
        const roundedDay = Math.round(tagSum * 100) / 100;
        printedTotal += roundedDay;
        total += tagSum;
        totalCustomers += kunden;
      }
    }
    output += "\n";
  });

  const netto = total / 1.19;
  const mwst = total - netto;
  const roundedTotal = Math.round(printedTotal * 100) / 100;
  const roundingDiff = Math.round((roundedTotal - total) * 100) / 100;
  const labelWidth = 24;
  function line(label, value) {
    return label.padEnd(labelWidth) + value.toFixed(2).replace(".", ",").padStart(10) + "\n\n";
  }
  output += "Quartals√ºbersicht (Q" + q + " " + year + ")\n";
  output += line("Summe Tagessummen:", roundedTotal);
  output += line("Exakte Gesamtsumme:", total);
  output += line("Rundungsdifferenz:", roundingDiff);
  output += line("Netto:", netto);
  output += line("MwSt (19%):", mwst);
  output += ("Gesamtanzahl Kunden:".padEnd(labelWidth) + String(totalCustomers).padStart(10) + "\n");

  const rp = document.getElementById("reduced-print");
  if (rp) {
    rp.innerText = output;
    rp.style.display = "block";
    setTimeout(() => {
      window.print();
      rp.style.display = "none";
    }, 100);
  }
}

function exportQuarterExcel() {
  const q = getSelectedQuarter();
  const months = getQuarterMonths(q);
  const year = selYear;
  const wb = XLSX.utils.book_new();
  const ws_data = [];
  let grandTotal = 0;
  let grandCustomers = 0;

  months.forEach(m => {
    const days = daysInMonth(year, m);
    let monthTotal = 0;
    let monthCustomers = 0;

    ws_data.push([]);
    ws_data.push([monthNames[m] + " " + year]);

    for (let d = 1; d <= days; d++) {
      const dateStr = String(d).padStart(2, "0") + "." + String(m + 1).padStart(2, "0") + "." + year;
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      const freeKey = "cf-" + year + "-" + m + "-" + d;
      const freeType = localStorage.getItem(freeKey);

      const hasEntries = rows && rows.some(r => {
        const a1 = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
        const a2 = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
        const tip = r.amountTip !== undefined ? r.amountTip : "";
        return (a1 && parseFloat(String(a1).replace(",", ".")) > 0) ||
               (a2 && parseFloat(String(a2).replace(",", ".")) > 0) ||
               (tip && parseFloat(String(tip).replace(",", ".")) > 0);
      });

      if (!hasEntries && freeType) {
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank" ? "Krankheitstag" : "Eigener freier Tag");
        ws_data.push([dateStr, label]);
        ws_data.push([]);
        continue;
      }

      let tagSum = 0;
      let kunden = 0;
      const dayLines = [];

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));
          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);

          if (sumVal > 0) {
            kunden++;
            const fmt = n => n.toFixed(2).replace(".", ",");
            const formattedSum = fmt(sumVal);
            const fmt1 = !isNaN(num1) ? fmt(num1) : "";
            const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
            const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";

            let parts = [];
            if (fmt1) parts.push(fmt1);
            if (fmt2) parts.push(fmt2);
            if (fmtTip) parts.push(fmtTip);

            if (parts.length > 1) {
              dayLines.push(["", formattedSum, parts.join(" + ")]);
            } else {
              dayLines.push(["", formattedSum, ""]);
            }
            tagSum += sumVal;
          }
        });
      }

      if (tagSum > 0) {
        
dayLines.forEach((l, index) => {
  if (index === 0) {
    ws_data.push([dateStr, l[1], l[2]]);
  } else {
    ws_data.push(["", l[1], l[2]]);
  }
});

        ws_data.push(["", "----------"]);
        ws_data.push(["", tagSum.toFixed(2).replace(".", ","), `|   ${kunden} Kunden`]);
        ws_data.push([]);
        monthTotal += tagSum;
        monthCustomers += kunden;
      }
    }

    if (monthTotal > 0) {
      const fmt = n => n.toFixed(2).replace(".", ",");
      const netto = monthTotal / 1.19;
      const mwst = monthTotal - netto;
      ws_data.push([]);
      ws_data.push(["Monats√ºbersicht " + monthNames[m] + " " + year]);
      ws_data.push(["Gesamtsumme", fmt(monthTotal)]);
      ws_data.push(["Netto", fmt(netto)]);
      ws_data.push(["MwSt", fmt(mwst)]);
      ws_data.push(["Gesamtanzahl Kunden", String(monthCustomers)]);
      ws_data.push([]);
    }

    grandTotal += monthTotal;
    grandCustomers += monthCustomers;
  });

  if (grandTotal > 0) {
    const fmt = n => n.toFixed(2).replace(".", ",");
    const netto = grandTotal / 1.19;
    const mwst = grandTotal - netto;
    ws_data.push([]);
    ws_data.push([`Quartals√ºbersicht Q${q} ${year}`]);
    ws_data.push(["Gesamtsumme", fmt(grandTotal)]);
    ws_data.push(["Netto", fmt(netto)]);
    ws_data.push(["MwSt", fmt(mwst)]);
    ws_data.push(["Gesamtanzahl Kunden", String(grandCustomers)]);
  }

  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "Quartal");
  const defaultName = `einnahmen_quartal_Q${q}_${year}.xlsx`;
  XLSX.writeFile(wb, defaultName);
}
function generateReducedPrint() {
  let output = "";
  const month = document.getElementById("selected-month").innerText;
  output += "Einnahmen " + month + "\n\n";

  let total = 0;
  let totalCustomers = 0;
  let printedTotal = 0;

  for (let d = 1; d <= selDays; d++) {
    const tbody = document.getElementById("day-" + d);
    if (!tbody) continue;

    const rows = tbody.querySelectorAll("tr.entry-row");
    // Falls es keine Eintragszeilen gibt, pr√ºfen ob der Tag als Urlaub oder Krankheit markiert ist.
    if (rows.length === 0) {
      // Typ des eigenen freien Tages aus dem localStorage abrufen, sofern Funktion verf√ºgbar.
      let freeType = null;
      try {
        if (typeof getFreeDayType === 'function') {
          freeType = getFreeDayType(d);
        }
      } catch (e) {
        freeType = null;
      }
      // Wenn der Tag als frei markiert ist, Grund in den Ausdruck aufnehmen.
      if (freeType) {
        // Datum im Format TT.MM.JJJJ
        const date = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
        // Menschlich lesbare Beschriftung abh√§ngig vom Typ
        const label = freeType === "urlaub"
          ? "Urlaubstag"
          : (freeType === "krank"
             ? "Krankheitstag"
             : "Eigener freier Tag");
        output += date.padEnd(12) + label + "\n\n";
      }
      continue;
    }

    let tagSum = 0;
    let kunden = 0;
    let zeilen = [];

    rows.forEach(r => {
      // Betragswerte als Strings auslesen und in Zahlen konvertieren
      const a1Str = r.querySelector(".amount1")?.value || "";
      const a2Str = r.querySelector(".amount2")?.value || "";
      const tipStr = r.querySelector(".amountTip")?.value || "";
      const num1 = parseFloat(String(a1Str).replace(",", "."));
      const num2 = parseFloat(String(a2Str).replace(",", "."));
      const numTip = parseFloat(String(tipStr).replace(",", "."));
      const sumVal = (isNaN(num1) ? 0 : num1) + (isNaN(num2) ? 0 : num2) + (isNaN(numTip) ? 0 : numTip);
      if (sumVal > 0) {
        kunden++;
        // Formatierfunktion f√ºr zwei Dezimalstellen mit deutschem Dezimaltrennzeichen
        const fmt = n => n.toFixed(2).replace(".", ",");
        const formattedSum = fmt(sumVal);
        // formatierte Einzelbetr√§ge
        const fmt1 = !isNaN(num1) ? fmt(num1) : "";
        const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
        const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";
        let line;
        let parts = [];
        if (fmt1) parts.push(fmt1);
        if (fmt2) parts.push(fmt2);
        if (fmtTip) parts.push(fmtTip);
        if (parts.length > 1) {
          line = formattedSum.padStart(10) + "   " + parts.join(" + ");
        } else {
          line = formattedSum.padStart(10);
        }
        zeilen.push(line);
        tagSum += sumVal;
      }
    });

    if (tagSum > 0) {
      // Datum im Format TT.MM.JJJJ
      const date = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
      const maxLines = Math.max(zeilen.length, 1);
      for (let i = 0; i < maxLines; i++) {
        const datum = i === 0 ? date.padEnd(12) : " ".repeat(12);
        // Zeile enth√§lt bereits gepaddeten Gesamtbetrag und ggf. separate Betr√§ge rechts davon.
        const einnahme = zeilen[i] || "";
        output += datum + einnahme + "\n";
      }
      output += " ".repeat(12) + "----------\n";
      output += " ".repeat(12) + tagSum.toFixed(2).replace(".", ",").padStart(10) + "   |   " + kunden + " Kunden\n\n";

      const roundedDay = Math.round(tagSum * 100) / 100;
      printedTotal += roundedDay;
      total += tagSum;
      totalCustomers += kunden;
    }
  }

  // Netto und MwSt aus der Gesamtsumme (inkl. Trinkgeld) berechnen
  const netto = total / 1.19;
  const mwst = total - netto;

    const roundedTotal = Math.round(printedTotal * 100) / 100;
  const roundingDiff = Math.round((roundedTotal - total) * 100) / 100;

const labelWidth = 24;
  // Helferfunktion f√ºr eine Zeile der Monats√ºbersicht
  function line(label, value) {
    return label.padEnd(labelWidth) + value.toFixed(2).replace(".", ",").padStart(10) + "\n\n";
  }

  // Monats√ºbersicht (FA-optimiert mit Rundungsdifferenz)
  output += "Monats√ºbersicht\n";
  output += "----------------\n\n";
  output += line("Summe Tagessummen:", roundedTotal);
  output += line("Exakte Gesamtsumme:", total);
  output += line("Rundungsdifferenz:", roundingDiff);
  output += line("Netto:", netto);
  output += line("MwSt (19%):", mwst);
  // Gesamtanzahl der Kunden anh√§ngen
  output += "Gesamtanzahl Kunden:".padEnd(labelWidth) + String(totalCustomers).padStart(10) + "\n\n";

  // Text in das versteckte Druckdiv schreiben und anzeigen
  const rp = document.getElementById("reduced-print");
  rp.innerText = output;
  rp.style.display = "block";
  // kurze Verz√∂gerung, damit das DOM aktualisiert wird
  setTimeout(() => {
    window.print();
    rp.style.display = "none";
  }, 100);
}
</script>
<script>
function updateCustomerTotal() {
  let totalCustomers = 0;
  const rows = document.querySelectorAll("tbody[id^='day-'] tr.entry-row");
  rows.forEach(row => {
    const amount1 = row.querySelector(".amount1")?.value || "";
    const amount2 = row.querySelector(".amount2")?.value || "";
    const tipVal = row.querySelector(".amountTip")?.value || "";
    let sum = 0;
    if (amount1) sum += parseFloat(amount1.replace(",", "."));
    if (amount2) sum += parseFloat(amount2.replace(",", "."));
    if (tipVal) sum += parseFloat(tipVal.replace(",", "."));
    if (sum > 0) totalCustomers++;
  });
  const target = document.getElementById("grand-customers");
  if (target) target.textContent = totalCustomers;
}

document.addEventListener("DOMContentLoaded", updateCustomerTotal);
document.addEventListener("input", function(e) {
  if (e.target.classList.contains("amount1") ||
      e.target.classList.contains("amount2") ||
      e.target.classList.contains("amountTip")) {

    updateCustomerTotal();

    const row = e.target.closest("tr.entry-row");
    const day = getDayFromEntryRow(row);
    if (day !== null) {
      updateDay(day);
    }
  }
});


// Delegate click events for scroll-to-summary elements to smoothly scroll to the monthly totals
document.addEventListener('click', function(event) {
  const circle = event.target.closest('.scroll-circle');
  if (circle && circle.closest('.scroll-to-summary')) {
    // Nur ein Klick direkt auf den Kreis-Pfeil in der Tageszeile
    // scrollt zur Monats√ºbersicht.
    event.preventDefault();
    const totals = document.getElementById('onscreen-totals');
    if (totals) {
      totals.scrollIntoView({ behavior: 'smooth' });
    }
  }
});


document.addEventListener('click', function(event) {
  // Nur ein Klick direkt auf den Kreis-Pfeil im unteren "Zur√ºck"-Bereich
  // soll scrollBackToLastEntry ausl√∂sen, nicht ein Klick daneben.
  const backCircle = event.target.closest('.scroll-back-wrapper .scroll-circle');
  if (backCircle) {
    event.preventDefault();
    scrollBackToLastEntry();
  }
});

// Keep track of which entry row currently holds the scroll indicator

// Hilfsfunktion: Liefert die Tagesnummer (1..31) f√ºr eine Eintragszeile
// oder null, falls die Zeile keinem Tag zugeordnet werden kann.
function getDayFromEntryRow(row) {
  if (!row) return null;
  const tbody = row.closest("tbody[id^='day-']");
  if (!tbody || !tbody.id) return null;
  const parts = tbody.id.split("-");
  if (parts.length < 2) return null;
  const day = parseInt(parts[1], 10);
  return isNaN(day) ? null : day;
}

// Entfernt die letzte Eintragszeile eines Tages, falls sie komplett leer ist
// (weder Betrag 1 noch Betrag 2) und es noch mindestens eine weitere Zeile
// in diesem Tag gibt. Dadurch verschwinden unbenutzte, per Enter erzeugte
// Zusatzzeilen automatisch, sobald im n√§chsten Tag weitergearbeitet wird.
function removeTrailingEmptyRow(day) {
  if (day == null) return;
  const tbody = document.getElementById("day-" + day);
  if (!tbody) return;

  let rows = tbody.querySelectorAll("tr.entry-row");
  let removed = false;

  // Alle leeren Zeilen am Ende eines Tages entfernen, aber immer
  // mindestens eine Zeile pro Tag √ºbrig lassen.
  while (rows.length > 1) {
    const lastRow = rows[rows.length - 1];
    const a1 = lastRow.querySelector(".amount1");
    const a2 = lastRow.querySelector(".amount2");
    const hasValue = (a1 && a1.value !== "") || (a2 && a2.value !== "");
    if (hasValue) break;
    lastRow.remove();
    removed = true;
    rows = tbody.querySelectorAll("tr.entry-row");
  }

  if (removed) {
    updateDay(day);
  }
}


function copyPrevAmount(button) {
  const row = button.closest('tr.entry-row');
  if (!row) return;

  // Alle Eintragszeilen im Monat in Dokument-Reihenfolge holen
  const allRows = Array.from(document.querySelectorAll('tbody[id^="day-"] tr.entry-row'));
  const idx = allRows.indexOf(row);
  if (idx <= 0) return; // keine vorherige Zeile im Monat

  // Geeignete vorherige Zeile mit einem gesetzten Betrag 1 suchen
  let prevInput = null;
  for (let i = idx - 1; i >= 0; i--) {
    const candidate = allRows[i].querySelector('.amount1');
    if (candidate && candidate.value !== "") {
      prevInput = candidate;
      break;
    }
  }
  if (!prevInput) return;

  const currentInput = row.querySelector('.amount1');
  if (!currentInput) return;
  currentInput.value = prevInput.value;
  currentInput.classList.remove('empty-input');
  currentInput.focus();
  if (typeof currentInput.select === "function") {
    currentInput.select();
  }

  if (typeof getDayFromEntryRow === "function") {
    const day = getDayFromEntryRow(row);
    if (day != null) {
      updateDay(day);
    }
  }
}

/**
 * Setzt einen Standardbetrag (z.B. 33 ‚Ç¨) in das Betrag-1-Feld der aktuellen Zeile.
 * Der Button steht links neben dem Feld und bezieht den passenden Tag √ºber den Parameter day.
 */
function setStandardAmountForRow(button, value, day) {
  const wrapper = button.closest('.amount1-wrapper');
  if (!wrapper) return;
  const input = wrapper.querySelector('.amount1');
  if (!input) return;

  input.value = value;

  if (typeof checkInput === "function") {
    checkInput(input);
  }

  if (typeof updateDay === "function" && !isNaN(day)) {
    updateDay(day);
  }

  input.focus();
  if (typeof input.select === "function") {
    input.select();
  }
}

let lastFocusedDay = null;

let currentScrollRow = null;

/**
 * Move the arrow indicator to the given entry row. The indicator is shown by
 * inserting a downward arrow character into the row's scroll-to-summary cell and
 * clearing it from any previous row. This ensures only one arrow is visible at
 * a time.
 * @param {HTMLElement} row The table row (tr.entry-row) to highlight.
 */
function updateScrollArrow(row) {
  // Remove arrow from previous row
  if (currentScrollRow && currentScrollRow !== row) {
    const prevCell = currentScrollRow.querySelector('.scroll-to-summary');
    if (prevCell) {
      prevCell.innerHTML = '';
      prevCell.classList.remove('active');
      prevCell.removeAttribute('title');
    }
  }
  currentScrollRow = row;
  // Set arrow and Text auf der aktuellen Zeile
  if (row) {
    const cell = row.querySelector('.scroll-to-summary');
    if (cell) {
      cell.innerHTML = '<span class="scroll-circle">‚Üì</span><span class="scroll-text"> zur Monats√ºbersicht</span>';
      cell.classList.add('active');
      cell.setAttribute('title', 'Zur Monats√ºbersicht scrollen');
    }
  }
}

// When an amount field gains focus, move the arrow to its row
document.addEventListener('focusin', function(e) {
  if (e.target && (e.target.classList.contains('amount1') || e.target.classList.contains('amount2'))) {
    const row = e.target.closest('tr.entry-row');
    if (row) {
      const day = getDayFromEntryRow(row);
      // Wenn von einem Tag zu einem anderen gewechselt wird, ggf. letzte
      // leere Zusatzzeile im vorherigen Tag entfernen.
      if (lastFocusedDay !== null && day !== null && day !== lastFocusedDay) {
        removeTrailingEmptyRow(lastFocusedDay);
      }
      lastFocusedDay = day;
      updateScrollArrow(row);
    }
  }
});

// Scroll to the monthly summary when the user clicks the scroll button
function scrollToTotals() {
  const totals = document.getElementById("onscreen-totals");
  if (totals) {
    totals.scrollIntoView({ behavior: "smooth" });
  }
}

// Scrollt zur zuletzt bearbeiteten Eintragszeile (falls vorhanden)
function scrollBackToLastEntry() {
  // Wenn keine Daten vorhanden sind, ganz nach oben zum Seitenanfang scrollen.
  if (!hasAnyDataInMonth()) {
    window.scrollTo({ top: 0, behavior: 'smooth' });
    return;
  }

  // Ansonsten wie bisher zur zuletzt bearbeiteten Eintragszeile scrollen.
  if (typeof currentScrollRow !== 'undefined' && currentScrollRow) {
    const rect = currentScrollRow.getBoundingClientRect();
    const rowTop = rect.top + window.pageYOffset;
    // Zielposition so berechnen, dass sie nicht kleiner als 0 ist. Wird der Wert
    // negativ, f√ºhrt scrollTo sonst nur an den Seitenanfang und nicht mittig.
    let target = rowTop - (window.innerHeight / 2) + (rect.height / 2);
    if (target < 0) target = 0;
    window.scrollTo({ top: target, behavior: 'smooth' });
  }
}
</script>


<script>
function exportExcel() {
  const wb = XLSX.utils.book_new();
  const ws_data = [];

  let total = 0;
  let totalCustomers = 0;

  for (let d = 1; d <= selDays; d++) {
    const dateStr = String(d).padStart(2, "0") + "." + String(selMonth + 1).padStart(2, "0") + "." + selYear;
    const tbody = document.getElementById("day-" + d);
    if (!tbody) continue;

    const rows = tbody.querySelectorAll("tr.entry-row");

    // Eigene freie Tage (Urlaub / Krankheit / sonstiger freier Tag) ohne Eintr√§ge
    // sollen ebenfalls im Excel erscheinen.
    if (rows.length === 0) {
      let freeType = null;
      try {
        if (typeof getFreeDayType === "function") {
          freeType = getFreeDayType(d);
        }
      } catch (e) {
        freeType = null;
      }

      if (freeType) {
        let label;
        if (freeType === "urlaub") {
          label = "Urlaubstag";
        } else if (freeType === "krank") {
          label = "Krankheitstag";
        } else {
          // z.B. √§ltere Daten, bei denen nur ein generischer Wert gespeichert wurde
          label = "Eigener freier Tag";
        }

        ws_data.push([dateStr, label]);
        ws_data.push([]); // Leerzeile als Abstand
      }
      // Keine Ums√§tze/Kunden f√ºr freie Tage
      continue;
    }

    let dayLines = [];
    let tagSum = 0;
    let kunden = 0;

    rows.forEach(r => {
      const a1Str = r.querySelector(".amount1")?.value || "";
      const a2Str = r.querySelector(".amount2")?.value || "";
      const tipStr = r.querySelector(".amountTip")?.value || "";

      const num1 = parseFloat(String(a1Str).replace(",", "."));
      const num2 = parseFloat(String(a2Str).replace(",", "."));
      const numTip = parseFloat(String(tipStr).replace(",", "."));
      const sumVal =
        (isNaN(num1) ? 0 : num1) +
        (isNaN(num2) ? 0 : num2) +
        (isNaN(numTip) ? 0 : numTip);

      if (sumVal > 0) {
        kunden++;
        const fmt = n => n.toFixed(2).replace(".", ",");
        const formattedSum = fmt(sumVal);
        const fmt1 = !isNaN(num1) ? fmt(num1) : "";
        const fmt2 = !isNaN(num2) && num2 > 0 ? fmt(num2) : "";
        const fmtTip = !isNaN(numTip) && numTip > 0 ? "Trinkgeld " + fmt(numTip) : "";

        let parts = [];
        if (fmt1) parts.push(fmt1);
        if (fmt2) parts.push(fmt2);
        if (fmtTip) parts.push(fmtTip);

        if (parts.length > 1) {
          dayLines.push(["", formattedSum, parts.join(" + ")]);
        } else {
          dayLines.push(["", formattedSum, ""]);
        }

        tagSum += sumVal;
      }
    });

    if (tagSum > 0) {
      dayLines.forEach((l, index) => {
        if (index === 0) {
          ws_data.push([dateStr, l[1], l[2]]);
        } else {
          ws_data.push(["", l[1], l[2]]);
        }
      });
      ws_data.push(["", "----------"]);
      ws_data.push(["", tagSum.toFixed(2).replace(".", ","), `|   ${kunden} Kunden`]);
      ws_data.push([]); // Leere Zeile
      total += tagSum;
      totalCustomers += kunden;
    }
  }

  // Monats√ºbersicht mit Netto und MwSt (inkl. Trinkgeld)
  const netto = total / 1.19;
  const mwst = total - netto;

  const fmt = n => n.toFixed(2).replace(".", ",");

  ws_data.push([]);
  ws_data.push(["Monats√ºbersicht"]);
  ws_data.push(["----------------"]);
  ws_data.push(["Gesamtsumme:", fmt(total)]);
  ws_data.push(["Netto:", fmt(netto)]);
  ws_data.push(["MwSt (19%):", fmt(mwst)]);
  ws_data.push(["Gesamtanzahl Kunden:", totalCustomers]);

  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "Einnahmen");

  const filename = `Einnahmen_${selYear}-${String(selMonth+1).padStart(2,"0")}.xlsx`;
  XLSX.writeFile(wb, filename);
}

</script>

<script>
// Lock-Funktionen f√ºr Monatssperre
function isMonthLocked(year, month) {
  return localStorage.getItem(`locked-${year}-${month}`) === "1";
}

function setMonthLocked(year, month, locked) {
  if (locked) {
    localStorage.setItem(`locked-${year}-${month}`, "1");
  } else {
    localStorage.removeItem(`locked-${year}-${month}`);
  }
}

function toggleLock() {
  const locked = isMonthLocked(selYear, selMonth);
  setMonthLocked(selYear, selMonth, !locked);
  applyLockStatus();
}

function applyLockStatus() {
  const locked = isMonthLocked(selYear, selMonth);
  const lockIcon = document.getElementById("month-lock-toggle");
  if (lockIcon) {
    lockIcon.textContent = locked ? "üîí" : "üîì";
    lockIcon.title = locked ? "Monat ist gesperrt. Klick zum Entsperren." : "Monat ist offen. Klick zum Sperren.";
  }

  document.querySelectorAll("input, button").forEach(el => {
    if (
      !el.classList.contains("nav-btn") &&
      el.id !== "month-lock-toggle" &&
      !el.closest("#month-nav")
    ) {
      el.disabled = locked;
    }
  });
}

// Sperrstatus beim Monatswechsel anwenden
const _origUpdateMonth = updateMonth;
updateMonth = function () {
  _origUpdateMonth();
  applyLockStatus();
};

// Sperrstatus beim JSON-Export ber√ºcksichtigen
const _origExportJSON = exportJSON;
exportJSON = function () {
  const data = {
    year: selYear,
    month: selMonth,
    days: {},
    free: {},
    locked: isMonthLocked(selYear, selMonth) ? true : false
  };

  for(let d = 1; d <= selDays; d++){
    const key = "day-" + selYear + "-" + selMonth + "-" + d;
    const raw = localStorage.getItem(key);
    if(raw) data.days[key] = JSON.parse(raw);

    const cf = "cf-" + selYear + "-" + selMonth + "-" + d;
    const freeVal = localStorage.getItem(cf);
    if(freeVal) data.free[cf] = freeVal;
  }

  const defaultName = "einnahmen_" + selYear + "-" + String(selMonth+1).padStart(2,"0") + ".json";
  let filename = prompt("Dateiname:", defaultName);
  if (!filename) return;
  if (!filename.toLowerCase().endsWith(".json")) {
    filename += ".json";
  }

  const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};

// Sperrstatus beim Import wiederherstellen
const _origImportJSON = importJSON;
importJSON = function (ev) {
  const file = ev.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      if(data.days){
        for(const key in data.days){
          localStorage.setItem(key, JSON.stringify(data.days[key]));
        }
      }
      if(data.free){
        for(const key in data.free){
          const val = data.free[key];
          if(val === 1 || val === "1" || val === true){
            localStorage.setItem(key, "urlaub");
          } else if(val === "urlaub" || val === "krank") {
            localStorage.setItem(key, val);
          } else {
            localStorage.setItem(key, "urlaub");
          }
        }
      }
      if(data.locked === true){
        localStorage.setItem(`locked-${data.year}-${data.month}`, "1");
      }
      alert("Import erfolgreich. Seite wird neu geladen.");
      location.reload();
    } catch(err) {
      alert("Fehler beim Import: " + err.message);
    }
  };
  reader.readAsText(file);
};

// Schnelleingabe f√ºr einen Standardbetrag (z.B. 33 ‚Ç¨) in das aktuell ausgew√§hlte Betrag-1-Fel
function generateYearOverview() {
  const year = selYear;
  let output = "";
  let grandTotal = 0;
  let grandCustomers = 0;

  output += "Einnahmen Jahres√ºbersicht " + year + "\n\n";

  for (let m = 0; m < 12; m++) {
    const days = daysInMonth(year, m);
    let monthTotal = 0;
    let monthCustomers = 0;

    for (let d = 1; d <= days; d++) {
      const key = "day-" + year + "-" + m + "-" + d;
      let rows = [];
      const raw = localStorage.getItem(key);
      if (raw) {
        try { rows = JSON.parse(raw); } catch (e) { rows = []; }
      }

      if (rows && rows.length) {
        rows.forEach(r => {
          const a1Str = r.amount1 !== undefined ? r.amount1 : (r.a1 || "");
          const a2Str = r.amount2 !== undefined ? r.amount2 : (r.a2 || "");
          const tipStr = r.amountTip !== undefined ? r.amountTip : "";
          const num1 = parseFloat(String(a1Str).replace(",", "."));
          const num2 = parseFloat(String(a2Str).replace(",", "."));
          const numTip = parseFloat(String(tipStr).replace(",", "."));
          const sumVal =
            (isNaN(num1) ? 0 : num1) +
            (isNaN(num2) ? 0 : num2) +
            (isNaN(numTip) ? 0 : numTip);
          if (sumVal > 0) {
            monthTotal += sumVal;
            monthCustomers++;
          }
        });
      }
    }

    if (monthTotal > 0) {
      const fmt = n => n.toFixed(2).replace(".", ",");
      const netto = monthTotal / 1.19;
      const mwst = monthTotal - netto;
      const label = (monthNames[m] + " " + year).padEnd(18);
      output += label
        + "Brutto: " + fmt(monthTotal).padStart(10)
        + "   Netto: " + fmt(netto).padStart(10)
        + "   MwSt: " + fmt(mwst).padStart(10)
        + "   Kunden: " + String(monthCustomers).padStart(4)
        + "\n";
      grandTotal += monthTotal;
      grandCustomers += monthCustomers;
    }
  }

  if (grandTotal > 0) {
    const fmt = n => n.toFixed(2).replace(".", ",");
    const netto = grandTotal / 1.19;
    const mwst = grandTotal - netto;
    output += "\n";
    output += "Jahresgesamt " + year + "\n";
    output += "-------------------------\n";
    output += "Brutto: ".padEnd(12) + fmt(grandTotal).padStart(10) + "\n";
    output += "Netto: ".padEnd(12) + fmt(netto).padStart(10) + "\n";
    output += "MwSt: ".padEnd(12) + fmt(mwst).padStart(10) + "\n";
    output += "Kunden: ".padEnd(12) + String(grandCustomers).padStart(10) + "\n";
  } else {
    output += "F√ºr das Jahr " + year + " liegen keine Eintr√§ge vor.\n";
  }

  const rp = document.getElementById("reduced-print");
  if (rp) {
    rp.innerText = output;
    rp.style.display = "block";
    setTimeout(() => {
      window.print();
      rp.style.display = "none";
    }, 100);
  }
}

</script>


<script>
(function(){
  function updateAdvancedControlsVisibility(){
    const input = document.getElementById('unlock-code');
    const adv = document.getElementById('advanced-controls');
    if(!input || !adv) return;
    const code = (input.value || '').trim();
    adv.style.display = (code === '1202') ? 'block' : 'none';
  }

  document.addEventListener('input', function(e){
    if(e && e.target && e.target.id === 'unlock-code'){
      updateAdvancedControlsVisibility();
    }
  });

  document.addEventListener('DOMContentLoaded', updateAdvancedControlsVisibility);
})();
</script>

</body>
</html>
